
 # 异步JavaScript

 ## 使用回调的异步编程

 在最基本的层面, JS异步编程是使用回调实现的

 ### 定时器

 一种最简单的异步操作, 就是在一定时间之后执行某个操作

 ### 事件

 客户端JS编程几乎全是事件驱动的. 等待用户做一些事, 然后响应用户事件

 ### 网络事件

 JS编程中另一个常见的异步操作来源是网络请求

 ## 期约(promise)

 这是一种为简化异步编程而设计的核心语言特性

 基于回调的异步编程有一个现实问题, 就是经常会出现回调多层嵌套的情况, 造成代码缩进过多难以阅读

 期约可以让这种嵌套回调以一种更线性的期约链形式表达出来, 更易于理解和阅读

 回调的另一个问题是难以处理错误. 如果一个异步函数抛出异常, 则该异常没有办法传播到异步操作的发起者(它的调用者已经不在调用栈里, 如果出现错误, 根本没法向调用者抛回错误).

 异步编程的一个基本事实就是它破坏了异常处理

 期约标准化了异步错误处理, 通过期约链提供了一种让错误正确的传播路径.

 ### 期约相关术语

 + 兑现(fulfill)
 + 拒绝(reject)
 + 待定(pending)
 + 落定(settle)
 + 解决(resolve)

调用一个期约的then()方法传入两个回调函数, 如果第一个回调被调用, 我们说期约得到`兑现`.
如果第二个被调用, 我们说期约被`拒绝`. 如果期约既没有`兑现`也没有`拒绝`, 那它就是`待定`.
而期约一旦兑现或被拒绝, 我们说它已经`落定`

要理解`解决`和`兑现`的关系 -- 但期约以一个非期约值解决时, 就会立即以这个值兑现

```js
function c1(res) {
  return res.json() // 返回一个期约, 这个期约的需要等待数据全部被处理才会被 解决
}

function c2(res) {
  console.log(res)
}

let p1 = fetch('xxx')
let p2 = p1.then(c1) // 此时 p1 是否兑现取决于 c1 是否兑现 (c1的兑现取决于数据何时传输完成)
let p3 = p2.then(c2) // 此时并不会立即执行c2, 需要等待 p1 兑现
```

### 期约的错误处理

catch 和 finally 方法

catch() 方法实际上是对以 null 为第一个参数, 以错误处理回调为第二个参数的 then() 调用的简写
```js
p.then(null, c)
// 等同于
p.catch(c)
```

注意: 在期约链的任何地方使用catch都是可以的. 

如果期约链的某一环会因错误而失败, 而该错误属于某种可恢复的错误, 不应该停止后续环节代码运行, 那么可以在链中插入一个catch()调用

这个catch只在期约抛出错误的时候才会被调用, 如果期约返回正常值, 这个catch()就会被跳过

