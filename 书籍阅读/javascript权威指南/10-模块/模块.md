
# 模块

模块化编程的目标是能够用不同作者和来源的代码模块组装成大型程序

实践中, 模块化的主要作用体现在封装和隐藏私有实现细节, 以及保证全局命名空间清洁上, 因而模块之间不会意外修改各自定义的变量,函数,和类

## 基于类,对象和闭包的模块

几年前, js还没有内置对模块的支持, 打包工具使用基于对象和闭包的模块化形式

类和对象的一个重要特性是: 可以充当自己的模块(或者说命名空间)

但是类和对象可以一定程度充当模块, 但是无法隐藏内部实现,例如一些方法并不希望暴露出去

此时需要用到自执行函数, 只返回需要暴露的方法, 变量出去

```js

const api = (() => {
  function getName() {

  }
  return {
    getName // 将需要的暴露出去
  }
})()

```

### 基于闭包的自动模块化

可以想象有一个工具, 他可以解析代码, 把每个文件的内容包装在一个立即调用的函数里面, 还可以跟踪每个函数的返回值, 并将所有内容拼接为一个大文件.
这就是 `webpack`的最基本原理
```js
const modules = {}
function require(moduleName) { return modules[moduleName] }

modules['sets.js'] = (function() {
  const exports = {}
  
  // 读取的js
  exports.xx = ...
  return exports
})();

const sets = require('sets.js')

```

## ES6 中的模块

ES6模块与Node的模块化在概念上是相同的: 
+ 每个文件本身都是模块, 在文件中顶一个常量, 变量, 函数, 类对这个文件而言都是私有的, 除非他们被显示导出

区别在于语法, 以及浏览器中定义模块的方式

ES6模块与普通脚本的区别:
+ 常规脚本中, 顶级变量, 函数等会进入全局变量, 所有所有脚本都能共享; ES6模块中每个文件都有自己的私有上下文
+ ES6模块中, 默认是严格模式
+ 常规脚本允许跨源加载, 模块脚本增加了跨源限制, 只能从包含模块的HTML文档所在的域加载模块, 除非服务器添加了适当的CORS头部允许跨源加载
  + 如果需要使用ES6模块, 需要启动一个静态web服务器



## 在页面中使用javaScript模块

在页面中使用ES6模块需要在 `script` 标签加上 `type="module"` 来只能这是一个模块

模块标签会在所有HTML解析完成之后才执行, 而普通标签加载完成之后就会执行

`type="module"` 和 `defer`属性效果类似

支持`type="module"`的浏览器也支持`<script nomodule>`. 支持模块的了浏览器会会略带有`nomodule`属性的脚本, 不执行他们

不支持模块的浏览器不认识`nomodule`属性, 所以会忽略这个属性的脚本, 而运行其他脚本. 

这个位兼容旧版本浏览器提供了一个强大的技术

## import() 动态导入

