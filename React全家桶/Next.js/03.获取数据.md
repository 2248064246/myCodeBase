# 获取数据

- `getStaticProps` 用于静态生成, 在构建时生成数据
- `getStaticPaths` 用于静态生成, 生成动态路由
- `getServerSideProps` 用于服务端渲染获取数据

## getStaticProps

```js
export async function getStaticProps(context) {
  return {
    // 返回这个props将被作为组件的props参数传入
    props: {}, // will be passed to the page component as props
  };
}
```

`context` 对象包含下列属性:

- `params` 包含动态路由的页面的路由参数, 一般来说是类如 `{id: xxx}` 这种.(如果页面名称是`[id].js`)
- `preview` 为`true`表示页面处于预览模式.
- `previewData` 包含由设置的预览数据`setPreviewData`
- `locale` 包含语言环境
- `locales` 包含所有受支持的语言环境(如果启用了国际化路由)
- `defaultLocale` 包含配置的默认语言环境

`getStaticProps` 应该返回一个对象

- `props` 一个可选对象, 将返回格页面组件
- `revalidate`
- `notFound` 一个可选布尔值, 允许页面返回 404 状态和页面

  ```js
  export async function getStaticProps(context) {
    const res = await fetch(`https://.../data`);
    const data = await res.json();

    if (!data) {
      return {
        notFound: true,
      };
    }

    return {
      props: { data }, // will be passed to the page component as props
    };
  }
  ```

- `redirect` 一个可选的重定向值, 允许重定向到内部和外部资源. 应该使用如下对象形式`{destination: string, permanent: boolean}

  ```js
  export async function getStaticProps(context) {
    const res = await fetch(`https://...`);
    const data = await res.json();

    if (!data) {
      return {
        redirect: {
          destination: '/',
          permanent: false,
        },
      };
    }

    return {
      props: { data }, // will be passed to the page component as props
    };
  }
  ```

### 增量静态再生

Next.js 允许在构建网站后创建或更新静态页面. 增量静态重新生成能够在每页的基础上使用静态生成, **而无需重建整个站点**

通过在`getStaticProps` 方法中返回带有`revalidate`属性的对象来开启增量静态再生成

```js
function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li>{post.title}</li>
      ))}
    </ul>
  );
}
export async function getStaticProps() {
  const res = await fetch('https://.../posts');
  const posts = await res.json();
  return {
    props: {
      posts,
    },
    // Nextjs 会重新将会重新构建页面
    // - 当一个新请求进入
    // - 并且10秒内只生效一次
    revalidate: 10, // In seconds
  };
}

export async function getStaticPaths() {
  const res = await fetch('https://.../posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id },
  }));

  // `fallback: 'blocking'
  // 当请求的路径不存在是, 将会使用server-render来构建这个页面
  // 并缓存下来用于下次访问
  return { paths, fallback: 'blocking' };
}

export default Blog;
```

## 读取文件

不能使用`__dirname`来获取路径, 因为在编译的时候代码会被编译到单独的目录中. 此时`__dirname`的目录和开发是不一致.

可以通过`process.cwd()`来获取 Next.js 的目录路径

```js
export async function getStaticProps() {
  const postsDirectory = path.join(process.cwd(), 'posts');
  const filenames = await fs.readdir(postsDirectory);

  const posts = filenames.map(async (filename) => {
    const filePath = path.join(postsDirectory, filename);
    const fileContents = await fs.readFile(filePath, 'utf8');

    // Generally you would parse/transform the contents
    // For example you can transform markdown to HTML here

    return {
      filename,
      content: fileContents,
    };
  });
  // By returning { props: { posts } }, the Blog component
  // will receive `posts` as a prop at build time
  return {
    props: {
      posts: await Promise.all(posts),
    },
  };
}
```

## getStaticPaths

只会在构建时调用

返回对象参数:

- `paths` 必填, 决定了那些路径将被预渲染

  ```js
  return {
  paths: [
    { params: { id: '1' } },
    { params: { id: '2' } }
  ],
  fallback: ...
  }
  ```

  有一点需要特别注意: 每个`params`必须与页面名称中使用的参数相匹配.

  - 如果页面名称是 `pages/posts/[postId]/[commentId]`, 则对应`params`包含`postId`和`commentId`
  - 如果页面名称是`pages/[...slug]`, 则`params`包含`slug`数组. 例如数组是`['foo', 'bar']`, 则生成`pages/foo/bar` 页面

- `fallback` 必填
  - `fallback: false` 任何未匹配的路径都将导致 404 页面
  - `fallback: true` 未匹配的路径允许返回一个`后备`页面
    这个适用于拥有很多静态页面的站点(页面大部分内容由数据生成). 如果新加入一条数据, 用户此时请求, 可以通过`fallback: true`来显示一个 loading 状态, 然后等待`getStaticProps`获取数据并渲染页面. 此时对于此条数据已经渲染了一个静态页面.
  - `fallback: 'blocking'` 和`fallback:true`不同的地方在于, 它没有回退状态, 而是再请求的时候会一直等待`getStaticProps` 获取数据并完成预渲染. **`fallback: 'blocking'`** 不会更新原有的页面, 要做到这一点需要配合`revalidate` 设置.

适用示例

```js
import { useRouter } from 'next/router';

function Post({ post }) {
  const router = useRouter();

  // If the page is not yet generated, this will be displayed
  // initially until getStaticProps() finishes running
  if (router.isFallback) {
    return <div>Loading...</div>;
  }

  // Render post...
}

// This function gets called at build time
export async function getStaticPaths() {
  return {
    // Only `/posts/1` and `/posts/2` are generated at build time
    paths: [{ params: { id: '1' } }, { params: { id: '2' } }],
    // Enable statically generating additional pages
    // For example: `/posts/3`
    fallback: true,
  };
}

// This also gets called at build time
export async function getStaticProps({ params }) {
  // params contains the post `id`.
  // If the route is like /posts/1, then params.id is 1
  const res = await fetch(`https://.../posts/${params.id}`);
  const post = await res.json();

  // Pass post data to the page via props
  return {
    props: { post },
    // Re-generate the post at most once per second
    // if a request comes in
    revalidate: 1,
  };
}

export default Post;
```

### 细节

`getStaticPaths` 在开发模式下, 将会在每次请求时都会被调用.

## getServerSideProps

如果组件中导出一个`async getServerSideProps` 函数, 则 Next.js 将会在每次请求的时候调用这个函数.

```js
export async function getServerSideProps(context) {
  return {
    props: {}, // will be passed to the page component as props
  };
}
```

context 参数:

- `params` 来自动态路由的`params`对象
- `req` http request 对象
- `res` http response 对象
- `query` http query string 字符串
- `preview` 是否是预览模式
- `previewData` 预渲染的数据

返回对象

- `props: Object` 用于组件的 `props`对象
- `notFound: Boolean` 告诉组件需要返回一个 404 页面

### 什么时候使用 `getServerSideProps`

必须通过获取数据来预渲染页面时, 才需要`getServerSideProps`.

第一字节时间比`getStaticProps` 快, 应为服务器需要花时间来计算和获取数据, 并且没有通过特殊设置将无法被 CDN 缓存.

### 细节

**只再服务端运行**

`getServerSideProps` 只运行在服务端, 不会运行在浏览器端.

- 当直接请求页面时，`getServerSideProps`会立即运行, 页面会根据返回的`props`进行重新渲染.

- 当页面通过`next/link` `next/router` 进行切换时, Next.js 会发送 API 给服务端, 然后运行`getServerSideProps`. 接着会返回一个`getSServerSideProps`运行结果的 JSON 数据. 这个 JSON 会包含获取的新数据, 然后页面会根据这个 JSON 进行重新渲染.

- `getServerSideProps` 只能比用于页面文件中

## 在客户端获取数据

如果页面需要经常更新的数据, 并且不需要预渲染这些数据, 此时可以通过客户端去获取这些数据. 例如一些特定于用于的数据.

### SWR

SWR 钩子用来在页面上获取数据的钩子.

```js
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then((res) => res.json());

function Profile() {
  const { data, error } = useSWR('/api/user', fetcher);

  if (error) return <div>failed to load</div>;
  if (!data) return <div>loading...</div>;
  return <div>hello {data.name}!</div>;
}
```
