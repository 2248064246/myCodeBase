
# 并发模型与事件循环

javaScript有一个基于事件循环的并发模型, 事件循环负责执行代码, 收集和处理事件以及执行队列中的字任务.

## 运行时概念

栈, 队列, 堆


栈: 函数调用形成了一个由若干帧组成的栈

堆: 对象被分配在堆中, 堆是一个用来表示一大块内存区域的计算机术语

队列: 一个JavaScript运行时包含了一个待处理消息的消息队列. 每个消息都关联着一个用以处理这个消息的回调函数

在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。

函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。


## 事件循环

每一个消息完整的执行后, 其它消息才会被执行. 

这个模型的一个缺点在于当一个消息需要太长时间才能处理完成, Web应用程序就无法处理与用户的交互, 例如其鼠标事件, 滚动时间等.

一个好的习惯是缩短单个消息的处理时间, 并在可能的情况下将一个消息裁减成多个消息


### 添加消息

在浏览器里, 每当一个事件发生并且有一个事件监听器绑定在该事件上时, 一个消息就会被添加进消息队列.


对于 setTimeout 函数, 待加入队列的消息和一个时间值（可选，默认为 0）。

这个时间值代表了消息被实际加入到队列的最小延迟时间。如果队列中没有其它消息并且栈为空，在这段延迟时间过去之后，消息会被马上处理。
但是，如果有其它消息，setTimeout 消息必须等待其它消息处理完。因此第二个参数仅仅表示最少延迟时间，而非确切的等待时间。


**零延时**

零延迟并不意味着回调会立即执行。以 0 为第二参数调用 setTimeout 并不表示在 0 毫秒后就立即调用回调函数。

基本上，setTimeout 需要等待当前队列中所有的消息都处理完毕之后才能执行，即使已经超出了由第二参数所指定的时间。


## 多个运行时互相通信

一个 web worker 或者一个跨域的 iframe 都有自己的栈、堆和消息队列。两个不同的运行时只能通过 postMessage 方法进行通信。

如果另一个运行时侦听 message 事件，则此方法会向该运行时添加消息。

## 永不阻塞

JavaScript的事件循环模型与许多其他语言不同的一个非常有趣的特性是，它永不阻塞。 处理 I/O 通常通过事件和回调来执行，所以当一个应用正等待一个 IndexedDB 查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，比如用户输入。


[深入: 微任务与Javascript运行时环境](https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth)

