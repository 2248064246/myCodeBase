# å¼‚æ­¥è¿­ä»£å™¨å’Œç”Ÿæˆå™¨

## å¼‚æ­¥è¿­ä»£å™¨

å®ƒå’Œæ™®é€šè¿­ä»£å™¨æœ€å¤§çš„åŒºåˆ«æ˜¯ next() ä¸­éœ€è¦è¿”å› promise, åŒæ—¶ä½¿ç”¨ Symbol.asyncIterator ä½œä¸ºåç§°

## å¼‚æ­¥ç”Ÿæˆå™¨

å¼‚æ­¥ç”Ÿæˆå™¨ yield è¿”å›é»˜è®¤ä¼šè¢«åŒ…è£…ä¸º promise å¯¹è±¡

**for/await ä¸å¸¸è§„è¿­ä»£å™¨å…¼å®¹, å› æ­¤ä¼šåœ¨å°è¯• Symbol.asyncIterator å¤±è´¥åå°è¯• Symbol.iterator**

## ç¤ºä¾‹

åŸºäºç”Ÿæˆå™¨çš„è®¡æ—¶å™¨

```js
const elapsedTime = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
// interval é—´éš”æ—¶é—´, max å¾ªç¯æ¬¡æ•°
async function* clock(interval, max = Infinity) {
  for (let count = 1; count <= max; count++) {
    await elapsedTime(interval);
    yield count;
  }
}
```

ä¸€ä¸ªå¼‚æ­¥å¾ªç¯é˜Ÿåˆ—

```js
/**
 * ä¸€ä¸ªå¼‚æ­¥å¯è¿­ä»£é˜Ÿåˆ—
 * enqueue()æ·»åŠ å€¼, dequeue()ç§»é™¤å€¼, dequeue() è¿”å›ä¸€ä¸ªæœŸçº¦.
 * è¿™ä¸ªç±»å®ç°äº† [Symbol.asyncIterator] å’Œ next(), å¯ä»¥ä¸ for/awaitä¸€èµ·ä½¿ç”¨
 * åœ¨è°ƒç”¨ close()æ–¹æ³•å‰, å¾ªç¯ä¸ä¼šç»ˆæ­¢
 */
class AsyncQueue {
  static EOS = Symbol('end-of-stream');
  constructor() {
    this.values = [];
    this.resolvers = [];
    this.closed = false;
  }

  enqueue(value) {
    if (this.closed) {
      throw new Error('AsyncQueue Closed');
    }
    if (this.resolvers.length > 0) {
      const resolve = this.resolvers.shift();
      resolve(value);
    } else {
      /* å…¥é˜Ÿå¤§äºå‡ºé˜Ÿæƒ…å†µä¸‹, ä¸´æ—¶ä¿å­˜å€¼ */
      this.values.push(value);
    }
  }

  dequeue() {
    if (this.values.length > 0) {
      /* å…¥é˜Ÿå¤§äºå‡ºé˜Ÿæƒ…å†µä¸‹ç›´æ¥æ¨å‡ºå€¼ */
      const value = this.values.shift();
      return Promise.resolve(value);
    } else if (this.closed) {
      return Promise.resolve(AsyncQueue.EOS);
    } else {
      /* åœ¨for/awaitå¾ªç¯ä¸­, è¿™é‡Œä¼šé¦–å…ˆè°ƒç”¨, åˆ›å»ºå¾…è§£å†³çš„æœŸçº¦. æœ‰å€¼å…¥é˜Ÿåä¼šç›´æ¥è§£å†³è¯¥æœŸçº¦ */
      /* ç†è®ºä¸Š, ä¸€ä¸ªå€¼å…¥é˜Ÿ, ä¾¿å¯¹åº”ç€ä¸€ä¸ªå¾…è§£å†³çš„æœŸçº¦ */
      return new Promise((resolve) => {
        this.resolvers.push(resolve);
      });
    }
  }

  close() {
    while (this.resolvers.length > 0) {
      this.resolvers.shift()(AsyncQueue.EOS);
    }
    this.closed = true;
  }
  [Symbol.asyncIterator]() {
    return this;
  }

  next() {
    return this.dequeue().then((value) =>
      value === AsyncQueue.EOS
        ? { value: undefined, done: true }
        : { value: value, done: false }
    );
  }
}

/**
 * æ„å»ºä¸€ä¸ªäº‹ä»¶æµ, è¿”å›ä¸€ä¸ªè¿­ä»£å™¨
 * @param {Element} elt
 * @param {*} type
 */
function eventStream(elt, type) {
  const q = new AsyncQueue();
  elt.addEventListener(type, (e) => q.enqueue(e));
  return q;
}

async function handleKeys() {
  /* æ­¤è¿­ä»£å™¨ä¼šç­‰å¾…é”®ç›˜äº‹ä»¶, æŒ‰ä¸‹æŒ‰é”®ä¾¿ä¼šè§¦å‘ä¸€ä¸ªæœŸçº¦å…‘ç° */
  for await (const event of eventStream(document, 'keypress')) {
    console.log(event.key);
  }
}

handleKeys();
```

## æ‰‹åŠ¨å®ç°å¼‚æ­¥è¿­ä»£å™¨ç±»

é™¤äº†ä¸Šé¢çš„å†™æ³•, è¿˜å¯ä»¥è¿™ä¹ˆå†™

```js
> æ¯éš”ä¸€ç§’æ‰“å°ä¸€æ¬¡
class Emitter {
  constructor(max) {
    this.max = max;
    this.asyncIdx = 0;
  }

  // å¼‚æ­¥è¿­ä»£å™¨
  // è¿™é‡Œä½¿ç”¨ç”Ÿæˆå™¨æ¥ä½¿çš„æ”¾å›ç¬¦åˆè¿­ä»£å™¨è§„èŒƒçš„å¯¹è±¡
  async *[Symbol.asyncIterator]() {
    while (this.asyncIdx < this.max) {
      yield new Promise((resolve) => {
        setTimeout(() => {
          resolve(this.asyncIdx++);
        }, 1000);
      });
    }
  }
}

// è¦ä½¿ç”¨ for await of, å¿…é¡»æ˜¯ async å‡½æ•°
async function asyncCount() {
  let emitter = new Emitter(5);

  for await (const x of emitter) {
    console.log(x);
  }
}
asyncCount(); // ğŸ‘âœ¨ NBå§
```
