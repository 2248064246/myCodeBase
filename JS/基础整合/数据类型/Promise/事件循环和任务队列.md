# 事件循环和任务队列

## js 执行上下文 和 执行上下文栈

当 JavaScript 代码片段运行时，它会在执行上下文中运行

有三种类型的代码可以创建新的执行上下文：

- 全局上下文是为运行代码主体而创建的执行上下文;也就是说，存在于 JavaScript 函数之外的任何代码。
- 每个函数都在自己的执行上下文中运行。这通常称为“本地上下文”。
- 使用不明智的 eval（） 函数也会创建一个新的执行上下文。

从本质上讲，每个上下文都是代码中的一个范围级别。当其中一个代码段开始执行时，将构造一个新的上下文来运行它;然后，当代码退出时，该上下文将被销毁。

> 创建每个上下文时，将其放置在执行上下文堆栈上。当它退出时，上下文将从上下文堆栈中删除。 这也被称为 `栈帧`

关于递归函数（即调用自身的函数，可能跨越多个深度或递归级别）的特别说明：对函数的每个递归调用都会创建一个新的执行上下文。这允许 JavaScript 运行时通过该递归跟踪递归级别和结果返回，但这也意味着每次函数递归时，都需要更多的内存来创建新上下文。

## js 运行时

js 运行时由以下部分组成:

- 一组执行上下文, 执行上下文栈
- 一个主线程
- 一组用于 worker 的其他线程
- 一个任务队列
- 一个微任务队列

除了主线程（某些浏览器在多个代理之间共享）之外，代理的每个组件对于该代理都是唯一的。

> 这里的代理指的是 `窗口`

### 事件循环

每个代理都由一个事件循环驱动, 该事件循环收集任何用户和其他事件，将任务排队以处理每个回调.

然后，它运行任何挂起的 JavaScript 任务，然后运行任何挂起的微任务，然后执行任何需要的渲染和绘制，然后再次循环以检查挂起的任务。

js 代码和 Web 浏览器本身的用户界面相同的线程中运行,共享相同的事件循环.

这是主线程，除了运行站点的主代码体外，它还处理接收和调度用户和其他事件，呈现和绘制 Web 内容等。

### 任务 与 微任务

任务是计划由标准机制运行的任何 JavaScript，例如最初开始执行程序、触发回调的事件等。除了使用事件之外，还可以使用 setTimeout（） 或 setInterval（） 对任务进行排队。

任务队列和微任务队列的区别:

+ 从任务队列执行任务时, 运行时会在事件循环的新迭代开始时执行队列中的每个任务。迭代开始之后添加到队列的任务在下一次迭代之前不会运行

+ 每次任务退出, 并且执行上下文为空时, 微任务队列中的每个微任务都会一次执行. 不同之处在于, 微任务的执行会一直持续到队列为空, 即使在此期间安排了新的微任务. (换句话说，微任务可以将新的微任务排入队列，这些新的微任务将在下一个任务开始运行之前和当前事件循环迭代结束之前执行。)
