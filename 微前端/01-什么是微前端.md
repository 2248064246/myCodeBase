
# 什么是微前端
[参考](https://juejin.cn/post/6844904162509979662)

微前端(Micro-Frontend)是一种类似于微服务的架构, 它将微服务的理念应用于浏览器端, 即将 Web 应用由单一的单体应用转变为多个小型前端因公聚合为一体的应用.

每个前端应用还可以独立运行, 独立开发, 独立部署. 

微前端不是单纯的前端框架或者工具, 而是一套架构体系, 这个概念最早在2016年底被提出

## 为什么会有微前端

任何新技术的产生都是为了解决现有场景和需求下的技术痛点, 微前端也不例外:

1. 拆分和细化: 当下前端领域, 单页面应用(SPA)是非常流行的项目形态, 而随着时间的推移以及应用功能的丰富, 单页面应用变得不再单一而是越来越庞大, 越来越难以维护, 往往是改动一处而动全身, 由此带来的成本也越来越高. 为前端的意义就是将这些庞大应用进行拆分, 并随之解耦, 每个部分可以单独进行维护和部署, 提升效率.
2. 整合历史系统: 在不少的业务中, 或多或少会存在一些历史项目, 这些项目大多采用老框架, 介于日常运营, 这些系统需要结合到新框架中来使用还不能抛弃, 对此我们也没有理由浪费时间和精力重写旧逻辑. 而微前端可以将这些系统进行整合, 在基本不修改原来逻辑的同时来兼容新老两套系统运行

## 实现微前端有哪些方案

| 方案               | 描述                                                                                     | 优点                                           | 缺点                                                                                                 |
| ------------------ | ---------------------------------------------------------------------------------------- | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| iframe             | 主应用单独是一个页面, 每个子应用嵌套一个iframe                                           | 实现简单, iframe天然自带隔离, 父子之间互不影响 | iframe的样式显示, 兼容性等都具有局限性, 且父子通信, 数据共享困难                                     |
| Web Components     | 每个子应用需要采用纯Web Components技术编写组件, 是一套全新的开发模式                     | 每个子应用有独立的script和css, 也可单独部署    | 对历史系统改造成本高, 子应用通信较为复杂, 易采坑                                                     |
| 组合式应用路由分发 | 每个子应用独立构建部署, 运行时由父应用来进行路由管控, 应用加载, 启动, 卸载, 以及通信机制 | 纯前端改造, 体验良好, 子应用相互隔离           | 需要设计和开发, 由于父子应用处于同一页面运行, 需要解决子应用的样式冲突, js变量污染, 通信机制等技术点 |

[关于 Web Components](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)

## 微前端由哪些模块组成

下微前端主要采用的是组合式应用路由方案，该方案的核心是“主从”思想，即包括一个基座（MainApp）应用和若干个微（MicroApp）应用，基座应用大多数是一个前端SPA项目，主要负责应用注册，路由映射，消息下发等，而微应用是独立前端项目，这些项目不限于采用React，Vue，Angular或者JQuery开发，每个微应用注册到基座应用中，由基座进行管理，但是如果脱离基座也是可以单独访问，基本的流程如下图所示：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/15/1721766ee9a543cf~tplv-t2oaga2asx-watermark.awebp)

基于目前的方案来说，一个微前端的基座框架需要解决以下问题：
1. 路由切换的分发问题
2. 主微应用的隔离问题
3. 通信问题


## 微前端的路由分发

作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：

1. 作为一个SPA的基座应用, 本身是一套纯前端项目, 想要展示微应用页面除了采用iframe之外, 要能先拉取到微应用的页面内容, 这就需要远程拉取机制
2. 远程拉取机制通常会采用fetch API 来首先获取微应用的HTML内容, 然后通过解析将微应用的JavaScript和CSS进行抽离, 采用eval方法来运行javaScript, 并将css和HTML内容append到基座应用中留给微应用的展示区域, 当微应用切换走时, 同步卸载这些内容, 这就是构成当前应用的展示流程
3. 这里会涉及css样式的污染和js对全局对象的污染, 这里需要隔离操作. 针对远程拉取流程, 已有线程库来实现,例如`import-html-entry`和`system.js`

对于路由分发而言, 以采用vue-router开发的基座SPA应用来举例

1. 当浏览器的路径变化后, vue-router会监听hashchange或者popstate事件, 从而获取到路由切换的时机
2. 最先接收到这个变化的是基座的router, 通过查询注册信息可以获取到转发到那个微应用, 经过一些逻辑处理后, 采用修改hash方法或者pushState方法来将路由信息推送给微应用的路由, 微应用可以有自己的路由监听机制
   

## 微前端的应用隔离

分为 主应用和微应用, 微应用和微应用之间的隔离(js, css)

css隔离: 
  1. 当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。
  2. 而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。
  
js隔离: 
  1. 当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。
   
沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。

## 微前端的消息通信

应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/17/1722065f24632ddb~tplv-t2oaga2asx-watermark.awebp)

用采用的是React或者是Vue，是可以结合Redux和Vuex来一起使用，实现应用之间的通信。

## 微前端有哪些框架

+ Single-Spa 最早的微前端框架, 兼容多种前端技术栈
+ Qiankun 基于Single-Spa, 阿里系开源微前端框架
+ Icestark 阿里飞冰微前端框架, 兼容多种前端技术栈
+ emp Webpack 5 Module Federation（联邦模块）方案