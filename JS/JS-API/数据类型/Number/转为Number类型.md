# 类型转换

ToNumber 转换规则
| 输入类型 | 结果 |
| --------- | -------------------------------------------------- |
| Undefined | NaN |
| Null | +0 |
| Boolean | 1 or +0 |
| Number | 不转换 |
| String | 参见下文具体规则 |
| Object | 1. 通过 ToPrimitive 返回原始值 2. ToNumber(原始值) |

String -> Number

> 很复杂....说简单的

- 各类进制数(16, 8, 2...)
  - 16 进制 `0x`开头
  - 8 进制 `0o`开头
  - 2 进制 `0b`开头
  - `0000123` 这种会被解析为 `10进制数`
- 空白符(行终止符)
  - 解析为数字 `0`
- 科学计数数字(e, E)
  - 例如 `10e3` 会被解析为`10000`
- 无穷数(Infinity)
  - 解析为 `Infinity`
- BigInt 字符串
  - `123n` 结果是 `NaN`

## 转为数字

**常见能够转为数字的方式**

- `Number()`
- `parseInt()` or `parseFloat()`
- `++` or `--`
- 一元操作符 `+` or `-` (正负号)
- 一元操作符(二进制操作符) `~` `|` `&` `^`
-  `==` 比较 (两边之一是数值的时候, 另一边会转为数值)

```js
// + or -
+'1.23'  // => 1.23  正号写在字符串前面将会发生类型转换
+new Date()  // 这样能够快速获得当前时间戳, 个人不推荐
// 很重要的一点, 这个 '+' 不必挨着字符串
+'123'; // => 123

// 所有可能会看到这种操蛋的玩意 (一元 +  优先级高于 加法运算符)
5 + +'123' + +true; // => 129
```

**对象转为数字**

```js
let a = {} + a; // => NaN
```

这里 a 对象执行`ToPrimitive`得到原始, 期望的是数字所以先执行`valueOf`方法(**对象默认的 valueOf 方法返回自身**), 显然不是原始值, 然后执行`toString`返回字符串 `{}`. 接着对字符串`{}`执行 `ToNumber`, 无法解析, 最终返回`NaN`

之所以 `+new Date` 能够返回数字, 是因为`Date` 有自己的`valueOf`方法

```js
let a = {
  valueOf() {
    return 1;
  },
};
+a; // => 1
```

现在也就能明白 `['']`, 和 `[1,2]` 转为数字的结果了

`parseInt`和`parseFloat` 有点特殊, 它们接受的是字符串(会将第一个参数转为字符串)

```js
parseInt('123'); // => 123
parseInt([1]); // => 1
parseInt({ a: 1 }); // => NaN

// 和普通的转数值不同, 它会优先解析出数字而抛弃非数字结果
parseInt('123n'); // => 123

// 并且它可以指定当前值为什么进制数, 最终结果是十进制数
parseInt('123', 16); // => 291

// 有一个非常有意思的坑
parseInt(1 / 0, 19); // 18

/**
 * 首先 1/0 在js中返回 Infinity
 * Infinity 转为字符串是 'Infinity'
 * 而19进制中, 字符 I或i 刚好对应 18, 所以结果为 18
 * 类似 parseInt('F', 16) 结果是 15
 */

// 还有这种
parseInt(false, 16); // 250 (结果来自16进制的'fa')
```

