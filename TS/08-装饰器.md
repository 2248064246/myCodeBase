
# 装饰器

这是一个处于 阶段二的实验室特性, 但是在TS已经的得到完整支持

## 开启装饰器特性
必须在命令行或tsconfig.json里启用experimentalDecorators编译器选项：
```json
{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true
  }
}
```

## 说明

装饰器是一种特殊类型的声明，它能够被附加到`类声明`，`方法`， `访问符`，`属性`或`参数`上


## 类装饰器

类装饰器在类声明之前被声明(紧靠着类声明). 类装饰器应用于类构造函数, 可以用来监视, 修改或者替换类定义.

类装饰器表达式会在运行时当做函数被调用, 类的构造函数作为其唯一的参数

如果类装饰器返回一个值, 它会使用提供的构造函数来替代类声明
> 注意: 如果需要返回一个新的构造函数, 必须注意处理好原来的原型链

```ts
'use strict';
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

function classDecorator<T extends { new (...args: any): {} }>(constructor: T) {
  console.log(constructor);
  return class extends constructor {
    // 可以重新返回一个构造函数
    name = 'Tom'; // 在这里会继承Cat, 然后在初始化 this.name = Tom
    /* 这里会破坏实例的 constructor  */
  };
}

@sealed // 装饰器可以叠加
@classDecorator
class Cat {
  name: string;
  constructor() {
    this.name = 'cat';
    console.log(this.name);
  }
  getName() {
    return 'hello' + this.name;
  }
}

Cat.prototype.getName = function () { // 不允许修改, 严格模式下报错
  return 'xxx';
};

let cat = new Cat();

console.log(cat.getName()); // helloTom

```

## 方法装饰器
方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数：

+ 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
+ 成员的名字。
+ 成员的属性描述符

如果方法装饰器返回一个值，它会被用作方法的属性描述符。