# setup()

`setup()` 钩子是在组件中使用组合式 API 的入口, 通常只在以下情况下使用:

1. 需要在非单文件组件中使用组合式 API
2. 需要在基于选项式 API 的组件中集成基于组合式 API 的代码时.

其他情况, 优先使用 `<script setup>`

## 基本使用

`setup()` 中返回的对象会暴露给模板和组件实例

```html
<script>
  import { ref } from 'vue';

  export default {
    setup() {
      const count = ref(0);

      // 返回值会暴露给模板和其他的选项式 API 钩子
      return {
        count,
      };
    },

    mounted() {
      console.log(this.count); // 0
    },
  };
</script>

<template>
  <button @click="count++">{{ count }}</button>
</template>
```

请注意在模板中访问从 setup 返回的 ref 时，它会自动浅层解包，因此你无须再在模板中为它写` .value`。当通过 this 访问时也会同样如此解包。

> 无法在 `setup` 中使用 `this` 获取组件实例

## 访问 pros

`setup()` 函数的第一个参数是组件的 `props`. 传入 setup 的 props 是响应式的.

不要通过`解构`获取 props 的属性, 那样会属性会失去响应性.

如果确实需要解构, 并且也想保持响应性, 需要使用 `toRefs()` 或 `toRef()` 两个工具函数

```js
import { toRefs, toRef } from 'vue';

export default {
  setup(props) {
    // 将 `props` 转为一个其中全是 ref 的对象，然后解构
    const { title } = toRefs(props);
    // `title` 是一个追踪着 `props.title` 的 ref
    console.log(title.value);

    // 或者，将 `props` 的单个属性转为一个 ref
    const title = toRef(props, 'title');
  },
};
```

## setup 上下文

`setup`中的第二个参数是一个上下文对象, 这个对象暴露了在`setup`可能需要用到的对象和方法

```js
export default {
  setup(props, context) {
    // 透传 Attributes（非响应式的对象，等价于 $attrs）
    console.log(context.attrs);

    // 插槽（非响应式的对象，等价于 $slots）
    console.log(context.slots);

    // 触发事件（函数，等价于 $emit）
    console.log(context.emit);

    // 暴露公共属性（函数）
    console.log(context.expose);
  },
};
```

`context` 不是响应式的, 所以可以安全的解构

```JS
export default {
  setup(props, { attrs, slots, emit, expose }) {
    ...
  }
}
```

其中, `attrs` 和 `slots` 都是有状态的属性, 他们总是会随着组件自身的更新而更新. 这意味着不应该解构 `attrs` 和 `slots`, 而是通过 `.` 访问.

## 暴露公共属性

通过 expose 方法可以显式的限制该组件暴露出去的属性.

当父组件通过 `模板引用(refs)`访问该组件的实例时, 将仅仅能访问 `expose`函数暴露出的内容

```js
export default {
  setup(props, { expose }) {
    // 让组件实例处于 “关闭状态”
    // 即不向父组件暴露任何东西
    expose();

    const publicCount = ref(0);
    const privateCount = ref(0);
    // 有选择地暴露局部状态
    expose({ count: publicCount });
  },
};
```

## 与渲染函数一起使用

`setup` 也可以返回一个渲染函数, 此刻函数中可以使用在同一个作用域下声明的响应式状态(非响应式状体不能使用吗??)

返回一个渲染函数将会组织返回其他东西.
