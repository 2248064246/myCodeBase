# Ts 与 组合式 API

[toc]

## 为组件 props 标注类型

### 使用 `<script setup>`

支持通过 `defineProps` 推导类型, 这称为`运行时声明`

```html
<script setup lang="ts">
  const props = defineProps({
    foo: { type: String, required: true },
    bar: Number,
  });

  props.foo; // string
  props.bar; // number | undefined
</script>
```

或者直接通过泛型来定义 props, 这称为`基于类型的声明`

```html
<script setup lang="ts">
  const props = defineProps<{
    foo: string;
    bar?: number;
  }>();
</script>
```

**编译器会尽可能地尝试根据类型参数推导出等价的运行时选项**

这种方式可以将类型声明提取出来

```html
<script setup lang="ts">
  /* 但是不能通过 import 引入, 只能写在本文件中 */
  interface Props {
    foo: string;
    bar?: number;
  }

  const props = defineProps<Props>();
</script>
```

### 语法限制

`defineProps()` 的泛型必须是下面之一:

- 一个类型字面量
- 对**同一个文件**中的一个接口或对象类型字面量的引用

> Vue 计划在未来的版本中解决`同一个文件`这个限制

### props 默认值

基于类型的声明使得 props 失去了默认值这个功能, 可以通过 `withDefaults()` 来解决

```js
export interface Props {
  msg?: string
  labels?: string[]
}

const props = withDefaults(defineProps<Props>(), {
  msg: 'hello',
  labels: () => ['one', 'two']
})

```

个人觉得有点麻烦

### 非 `<script setup>` 场景下

在没有使用 `<script setup>`情况下, 开启 props 的类型推导, 必须是要`defineComponent()`.

传入`setup()`的 props 类型是从 `props` 选项中推导而来

```js
import { defineComponent } from 'vue';

export default defineComponent({
  props: {
    message: String,
  },
  setup(props) {
    props.message; // <-- 类型：string
  },
});
```

## 为组件 emits 标注类型

在`<script setup>` 中, `emit`的类型标注也可以通过运行时或类型声明进行:

```html
<script setup lang="ts">
  // 运行时
  const emit = defineEmits(['change', 'update']);

  // 基于类型
  const emit = defineEmits<{
    (e: 'change', id: number): void;
    (e: 'update', value: string): void;
  }>();
</script>
```

若没有使用 `<script setup>`，defineComponent() 也可以根据 emits 选项推导暴露在 setup 上下文中的 emit 函数的类型：

```js
import { defineComponent } from 'vue';

export default defineComponent({
  emits: ['change'],
  setup(props, { emit }) {
    /* 需要手动触发??? */
    emit('change'); // <-- 类型检查 / 自动补全
  },
});
```

## 为 `ref()` 标注类型

ref 会根据初始化时的值推导其类型：

```js
import { ref } from 'vue';

// 推导出的类型：Ref<number>
const year = ref(2020);

// => TS Error: Type 'string' is not assignable to type 'number'.
year.value = '2020';
```

如果需要手动指定类型, 可以通过 `Ref` 这个类型:

```js
import { ref } from 'vue';
import type { Ref } from 'vue';

const year: Ref<string | number> = ref('2020');

year.value = 2020; // 成功！
```

或者, 在调用`ref()` 时传入一个泛型参数, 来覆盖默认的推导行为:

```js
// 得到的类型：Ref<string | number>
const year = (ref < string) | (number > '2020');

year.value = 2020; // 成功！
```

如果指定了一个泛型参数, 但是没有给出初始值, 那么会默认加上一个 `undefined`的联合类型:

```js
// 推导得到的类型：Ref<number | undefined>
const n = ref<number>()
```

## 为 reactive() 标注类型

`reactive()` 会隐身地从它地参数中推导类型:

```js
import { reactive } from 'vue';

// 推导得到的类型：{ title: string }
const book = reactive({ title: 'Vue 3 指引' });
```

要显示地标注一个 `reactive` 变量的类型, 可以使用接口:

```ts
import { reactive } from 'vue';

interface Book {
  title: string;
  year?: number;
}

const book: Book = reactive({ title: 'Vue 3 指引' });
```

> 不要用`泛型`去标注, 因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。

## 为 `computed()` 标注类型

`computed()` 会自动从返回值推导类型.

也可以通过泛型标注:

```js
const double =
  computed <
  number >
  (() => {
    // 若返回值不是 number 类型则会报错
  });
```

## 为事件处理其标注类型

就是普通函数的参数类型标注

## 为 provide / inject 标注类型

需要使用 Vue 提供的 `InjectionKey` 接口

```ts
import { provide, inject } from 'vue';
import type { InjectionKey } from 'vue';

const key = Symbol() as InjectionKey<string>;

provide(key, 'foo'); // 若提供的是非字符串值会导致错误

const foo = inject(key); // foo 的类型：string | undefined
```

建议将 key 放入单独的文件中

单使用字符串注入 key 时, 需要通过泛型显示声明

```ts
/* 这里没有提供默认值 */
const foo = inject<string>('foo'); // 类型：string | undefined

/* 这是提供了默认值,  */
const foo = inject<string>('foo', 'bar'); // 类型：string

/* 也可以使用强制转换 */
const foo = inject('foo') as string;
```

## 为模板引用标注类型

模板引用需要通过一个显式指定的泛型参数和一个初始值 null 来创建：

```html
<script setup lang="ts">
  import { ref, onMounted } from 'vue';

  /* 这里就获取了 DOM ??? */
  const el = ref<HTMLInputElement | null>(null);

  onMounted(() => {
    el.value?.focus();
  });
</script>

<template>
  <input ref="el" />
</template>
```

注意为了严格的类型安全，有必要在访问 el.value 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 ref 的值都是初始的 null，.

## 为组件模板引用标注类型

```html
<!-- MyModal.vue -->
<script setup lang="ts">
  import { ref } from 'vue';

  const isContentShown = ref(false);
  const open = () => (isContentShown.value = true);

  defineExpose({
    open,
  });
</script>
```

为了获取 MyModal 的类型，我们首先需要通过 typeof 得到其类型，再使用 TypeScript 内置的 InstanceType 工具类型来获取其实例类型：

```html
<!-- App.vue -->
<script setup lang="ts">
  import MyModal from './MyModal.vue';

  const modal = ref<InstanceType<typeof MyModal> | null>(null);

  const openModal = () => {
    modal.value?.open();
  };
</script>
```
