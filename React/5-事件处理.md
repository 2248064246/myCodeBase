# 事件处理

React 组件的事件处理和 DOM 元素的事件有一点区别

1. React 的事件命名采用小驼峰形式, 而不是纯小写
2. React 不能通过返回`false`的方法阻止默认行为, 必须显示使用`preventDefault`
3. JSX 中事件回调必须传入一个函数作为事件处理函数, 而不是一个字符串
4. React 中事件回调参数`event`是一个合成值, React 根据 W3C 规范来定义这些合成事件, 所以不需要担心跨浏览器问题
5. JSX 中无法在使用原本的 DOM 事件

```js
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState((prevState) => ({
      isToggleOn: !prevState.isToggleOn,
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}
```

## 事件中的 this 问题

必须谨慎对待 jsx 回调函数中 this, 传入给事件的`this.handleClick`虽然通过 this 访问, 但是 React 在在处理的时候如果没有绑定 this, 则函数的 this 为 undefined.

这与 JS 函数工作原理有关, 通常情况下, 如果没有在方法后面添加`()`, 例如 `onClick={this.handleClick}`, 此时应该为这个方法绑定`this`
(应为这只是将这个函数赋值给 `onClick` 变量, 如果后续 `onClick()` 这么调用, 则 this 就会出现变化. 这会导致 this 无法预测)

处理方式有三种:

1. 使用 class fields 语法 `handleClick = () => {console.log(this)}`
2. 使用箭头函数 `onClick={(e) => this.handleClick(e)}`
3. 手动绑定 this `onClick={this.handClick.bind(this)}`

## 向事件处理程序传递参数

有两种方式向事件处理函数传递参数:

```js
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```

以上两种方式都等价. 第二种方式中, `e` 会作为第二个参数传递
