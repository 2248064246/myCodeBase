
# 原型

## 原型赋值时候的屏蔽现象

例如我没给一个对象赋值`myObject.bar = 'foo'`, 会有以下三种情况

1. 如果在原型链上层存在`bar`属性, 且是普通属性, 则会在 `myObject` 上创建一个 `bar` 属性, 并赋值
2. 如果在原型链上存在`writable: false` 的`bar`属性, 则赋值会失败, 在严格模式下还会抛出错误
3. 如果在原型链上存在一个 bar 的 `setter`, 那就一定会调用这个setter, `bar` 不会被添加到`myObject`

> 第二种情况最让人意外, 只读属性会阻止链下层隐式创建同名属性

> 更奇怪的是, 这个限制只发生在 `=` 赋值, 使用`Object.defineProperty()` 并不会收到影响
关于这一点, 在`犀牛书`上有说明 **属性赋值查询原型链只为确定是否允许赋值**

查询属性时会用到原型链, 而设置属性时不影响原型链是一个重要的JS特性

属性赋值要么失败, 要么在对象上创建或设置值, 但有一个例外, 如果 `o` 继承一个属性`x`, 而`x`有`setter`, 则不会失败, 也不会创建(上面的第三点)

属性赋值失败情况
1. 有一个只读自有属性p: 不可能设置只读属性
2. 有一个只读继承属性p: 不可能用同名自有属性隐藏只读继承属性
3. 没有自有属性p, o没有继承通过setter方法定义的属性p, o的extensible: false, 则不能将p定义在o上


示例二
```js
var aObj = {a: 1}
var bObj = Object.create(aObj)

bObj.a++

aObj.a // 1 (没想到吧)
bObj.a // 2 
```
首先 `bObj.a++` 等同于 `bObj.a = bObj.a + 1`, 先从原型链获取值, 然后再在`bObj`上创建`a`属性并赋值


## 类

为什么类会在原型里面, 这是js一个特性--类基于原型实现

实际上在ES6的class语法出来之前, 并没有真正上的类的定义(一切都是靠社区的规范, 以及靠原型的特性来实现的类的特性)

有一句话在js中叫做`万物皆对象`, 在JS中没有类, 对象直接描述自己的行为(实际上可以理解为, 类也是对象)

要实现继承, 即意味着复制(完全复制类上面的方法和属性, 实例之前的修改并不会影响类), 但是JS并不会复制对象属性.

相反会在两个对象之间创建关联, 这样对象就可以通过`委托`访问另一个对象的属性和函数, `委托`这个术语可以更加准确的描述js中对象的关联机制

所以: `是委托而不是继承`

```
注: 考虑到JavaScript的工作方式，由于原型链等特性的存在，在不同对象之间功能的共享通常被叫做 委托 - 特殊的对象将功能委托给通用的对象类型完成。这也许比将其称之为继承更为贴切，因为“被继承”了的功能并没有被拷贝到正在“进行继承”的对象中，相反它仍存在于通用的对象中。
```
