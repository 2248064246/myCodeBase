# 运算操作

基本的 `+ - * / %` 操作并不是这里主要的关注点.

主要注意 `位运算` 以及它们和普通运算的差异

## 位运算

> 二进制运算都是按照`补码形式参与运算的`

位操作符期待整数操作数, 而且将他们当成 32 整数而不是 64 位浮点数

然后在将得到的数值**强制转换为 32 位数, 丢弃小数部分和第 32 位以外的部分**

## & | ^ ~

- & 按位与
  ```js
    // & 与运算
    0&0=0;  0&1=0;   1&0=0;    1&1=1;
  ```
- | 按位或
  ```js
    // | 或运算
    0|0=0;  0|1=1;  1|0=1;   1|1=1;
    // 有一种用法是使用或运算来去除小数(只保留整数部分)
    0 | 1.89 // => 1 类似Math.ceil(), 但是只能正对32位整数
  ```
- ^ 按位异或
  ```js
    // ^ 异或运算
    0^0=0;  0^1=1;  1^0=1;   1^1=0;
  ```
- ~ 按位非

  ```js
  // ~ 是取反(对二进制取反)操作
  ~6; // => -7 这里会等于 -7 的原因是 6的源码取反之后在转为10进制输出的问题

  // 6 -> 00000110(补码) -> 取反 -> 11111001(补码) -> 转10进制 -> 先将补码-1 -> 11111000 -> 补码转原码 -> 符号位不变, 其余取反 -> 10000111 -> 结果是 -7

  // 取反的一个用是用于判断 -1(程序标志位)
  ~'abc'.indexOf('x'); // 如果是在此时不需要 === -1, 因为它的结果是 0
  ```

| 运算符           | 用法    | 描述                                                                |
| ---------------- | ------- | ------------------------------------------------------------------- | --- | --------------------------------------------------------- |
| `&` 与           | `a & b` | 对于一个二进制数字，二者都为 1 时，结果为 1，否则为 0               |
| `                | ` 或    | `a                                                                  | b`  | 对于一个二进制数字，至少有一个为 1 时，结果为 1，否则为 0 |
| `^` 异或         | `a^b`   | 对于一个二进制数字，有且只有一个为 1 时，结果为 1，否则为 0         |
| `~` 非           | `~a`    | 翻转二进制数字，即 0 变成 1，1 变成 0                               |
| `<<` 左移        | `a<<b`  | 将 a 的二进制形式向左移动 b（<32）位，右边用 0 填充                 |
| `>>` 有符号右移  | `a>>b`  | 将 a 的二进制表示向右移动 b（<32）位，丢弃被移出的位                |
| `>>>` 无符号右移 | `a>>>b` | 将 a 的二进制表示向右移动 b（<32）位，丢弃被移出的位，左边用 0 填充 |


