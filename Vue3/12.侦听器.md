# 侦听器 Watcher

计算属性允许声明性的计算衍生值. 然后在某些情况下, 需要在状态变化时执行一些`副作用`: 例如修改 DOM, 执行异步操作等

在`选项式API`中可以通过配置`watch`来侦听响应式数据变化

## 深层侦听器

`watch` 默认式浅层的, 被侦听的属性,只在被重新赋值时才会触发回调函数.

开启深层侦听:

```js
export default {
  watch: {
    someObject: {
      handler(newValue, oldValue) {
        // 注意：在嵌套的变更中，
        // 只要没有替换对象本身，
        // 那么这里的 `newValue` 和 `oldValue` 相同
      },
      deep: true,
    },
  },
};
```

> 深度侦听需要遍历被侦听对象中的所有嵌套的属性，当用于大型数据结构时，开销很大。因此请只在必要时才使用它，并且要留意性能。

## 即时回调的侦听器

`watch` 默认时懒执行的: 只有当数据源变化时才会执行回调.

可以通过增加 `immediate: true` 属性来让它立即执行

```js
export default {
  // ...
  watch: {
    question: {
      handler(newQuestion) {
        // 在组件实例创建时会立即调用
      },
      // 强制立即执行回调
      immediate: true,
    },
  },
  // ...
};
```

## 回调的触发机制

**默认情况下, 用户创建的侦听器回调, 都会在 Vue 组件更新之前被调用**

这意味着你在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。

如果想在侦听器中能够访问被 Vue 更新之后的 DOM, 需要指明 `flush: 'post'` 选项

```js
export default {
  // ...
  watch: {
    key: {
      handler() {},
      flush: 'post',
    },
  },
};
```

## this.$watch()

可以通过组件实例的 `$watch()` 来命令式的创建一个侦听器;

```js
export default {
  created() {
    this.$watch('question', (newQuestion) => {
      // ...
    });
  },
};
```

## 停止侦听其

```js
const unwatch = this.$watch('foo', callback);

// ...当该侦听器不再需要时
unwatch();
```


