
# 原型

## 原型赋值时候的屏蔽现象

例如我没给一个对象赋值`myObject.bar = 'foo'`, 会有以下三种情况

1. 如果在原型链上层存在`bar`属性, 且是普通属性, 则会在 `myObject` 上创建一个 `bar` 属性, 并赋值
2. 如果在原型链上存在`writable: false` 的`bar`属性, 则赋值会失败, 在严格模式下还会抛出错误
3. 如果在原型链上存在一个 bar 的 `setter`, 那就一定会调用这个setter, `bar` 不会被添加到`myObject`

> 第二种情况最让人意外, 只读属性会阻止链下层隐式创建同名属性

> 更奇怪的是, 这个限制只发生在 `=` 赋值, 使用`Object.defineProperty()` 并不会收到影响
关于这一点, 在`犀牛书`上有说明 **属性赋值查询原型链只为确定是否允许赋值**

查询属性时会用到原型链, 而设置属性时不影响原型链是一个重要的JS特性

属性赋值要么失败, 要么在对象上创建或设置值, 但有一个例外, 如果 `o` 继承一个属性`x`, 而`x`有`setter`, 则不会失败, 也不会创建(上面的第三点)

属性赋值失败情况
1. 有一个只读自有属性p: 不可能设置只读属性
2. 有一个只读继承属性p: 不可能用同名自有属性隐藏只读继承属性
3. 没有自有属性p, o没有继承通过setter方法定义的属性p, o的extensible: false, 则不能将p定义在o上


示例二
```js
var aObj = {a: 1}
var bObj = Object.create(aObj)

bObj.a++

aObj.a // 1 (没想到吧)
bObj.a // 2 
```
首先 `bObj.a++` 等同于 `bObj.a = bObj.a + 1`, 先从原型链获取值, 然后再在`bObj`上创建`a`属性并赋值


