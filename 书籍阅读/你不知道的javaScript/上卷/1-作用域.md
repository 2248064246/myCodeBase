

# 你所不知道的javaScript上卷

[TOC]

## 作用域是什么
> 简单来说就是能够存储和访问变量的能力
### 编译原理
> JS代码的编译发生在代码执行前的几微秒
+ 分词/词法分析
+ 解析/语法分析
  + AST语法树
+ 代码生成
  + 将AST转换为可执行代码

### 理解作用域
> 进行 var a = 2 操作过程来说明

+ 编译器处理过程 (`声明` 和 `赋值`)
  + 编译器会查询作用域中是否已经存在 `a`变量, 如果存在则忽略 `var a` 声明, 不存在则创建 `a` 变量
  + 接下来编译器会生成运行时代码来进行赋值操作, 然后会查找作用域中是否存在 `a`, 存在直接使用这个变量, 不存在会沿着作用域查找

+ 引擎是如何查找变量
  + LHS
    + 赋值查询, 需要将值赋值给变量
  + RHS
    + 取值查询, 只需要拿到变量的值
  + 他们的区别
    + RHS 如果没有找到会抛出 `ReferenceError`, 表示没有该变量的引用(该变量未找到)
    + LHS 如果没有找到, 引擎会自动帮你创建一个(一般是全局变量)
    ```javaScript
      function foo(a) {
        console.log(a + b) // 这里会抛出错误, b没有找到
        b = a // 这里会自动创建一个全局变量 b
      }
      foo(2)
    
    ```
    + RHS 查询中, 找到了, 但是如果尝试对这个变量进行不合理的操作, 例如: 对非函数进行函数调用, 引用 'null, 'undefined' 类型中的属性, 引擎会抛出 `TypeError` 错误

### 词法作用域
> 作用域有两种工作模型: 词法作用域(大多数编译器使用), 动态作用域

+ 什么是词法作用域
  + 词法作用域就是定义在词法阶段的作用域, 是由写代码时变量和块作用域写在哪里来决定的

> 作用域查找

+ 作用域查找会在找到第一个匹配的标识符时停止(逐级向上查找)
+ 遮蔽效应
  + 在多层的嵌套作用域中, 可以定义同名的标识符, 这就会造成 `遮蔽效应`
  + 内部标识符 遮蔽 了外部的标识符
+ 处理遮蔽效应
  + 使用 'window' 全局变量, 可以不直接通过`标识符`来查找, 而是通过 `window.标识符`

> 无论函数在哪里被调用, 也无论被如何调用, 它的词法作用域都只由函数声明时所处的位置决定

> 词法作用域只会查找一级标识, 找到这个变量之后, 对象属性访问规则会接管之后的属性访问

### 欺骗词法作用域
> 会造成性能下降
+ `eval`
  > eval() 接收一个字符串, 并将该字符串作为代码运行
  + 如果 eval() 中所执行的代码包含一个或者多个声明, 就会修改`eval()`所在的词法作用域
    + 就是说 `eval()` 中的代码就像是原本就写在那里一样
  + 在严格模式中, `eval()`拥有自己的作用域
    + `eval()` 像是一个自执行函数一样, 有作用域, 也会沿着作用域查找
+ `with`
  > 不要用它


## 函数作用域和块作用域

### 函数中的作用域

> javaScript 具有基于函数的作用域

> 属于这个函数的全部变量可以在整个函数范围内访问 

### 隐藏内部实现

> 函数可以隐藏变量 -- 最小授权或最小暴露原则

> 同时可以避免同名标识符之间的冲突

变量冲突处理
  + 全局命名空间, 使用一个足够特殊的变量名来包裹所有的内部方法和变量
  + 模块管理

### 函数作用域

+ 使用函数来隐藏变量会导致额外问题
  + 函数要具有函数名, 这会 `污染` 全局变量
  + 函数需要通过函数名调用
+ JavaScript 提供了解决上述问题的方法
  + 匿名函数 和 自执行函数

> 函数声明和函数表达式: function 是否在声明中的第一个词, 是就是函数声明

```javaScript
  (function a() {})() // 这是一个函数表达式

  function a () {} // 这是一个函数声明

```
+ 函数表达式可以是匿名的, 函数声明必须要函数名


### 块作用域

> var 定义的变量最终都会处于外部作用域

+ `width` 拥有块级作用域
+ `try/catch` 中 `catch` 里面拥有块级作用域
  ```javaScript
    try {
      undefined(); // 执行一个非法操作, 来抛出异常
    }.catch(err){
      console.log(err)
    }
    console.log(err) // 此时err 并不存在

  ``` 
+ `let` 关键字可以将变量绑定到所在的任意作用域中,  let 为其声明的变量隐式的劫持了所在的块作用域
+ `const` 创建不变的常量, 也是块级作用域变量


块作用域的优点

1. 变量的附属关系更加清晰, 代码更易于维护
2. 不会变量提升



  