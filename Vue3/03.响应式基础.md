# 响应式基础

Vue3 使用 `JavaScript Proxy` 来实现响应式代理. 这和 Vue2 是一个很大的区别.

需要注意下面这个边界情况:

```js
export default {
  data() {
    return {
      someObject: {},
    };
  },
  mounted() {
    const newObject = {};
    this.someObject = newObject;

    console.log(newObject === this.someObject); // false
  },
};
```

当你在赋值后再访问 this.someObject，此值已经是原来的 newObject 的一个响应式代理。**与 Vue 2 不同的是，这里原始的 newObject 不会变为响应式：请确保始终通过 this 来访问响应式状态。**


## DOM更新时机

得注意 DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次声明更改，每个组件都只需要更新一次。

其实就是将 `Watcher`收集到一个队列, 然后放入微任务任务队列执行

## 深层相应性

Vue 或递归data中对象

## 浅层响应性

Vue2 中如果对象被冻结,封闭是不会进行响应式代理的.(这一点应该在Vue3 中也是一样的)

Vue3 中新加了中浅层响应方法 -- 它们仅在顶层具有响应性.