# 概述

## WebCodecs 是什么

WebCodecs API 为 Web 开发人员提供了对视频流的各个帧和音频块的低级访问。它对于需要完全控制媒体处理方式的 Web 应用程序非常有用。例如，视频或音频编辑器以及视频会议。

WebCodecs API 提供对浏览器中已有编解码器的访问。它允许访问原始视频帧，音频数据块，图像解码器，音频和视频编码器以及解码器。

## 为什么需要 WebCodecs

许多 Web API 在内部使用媒体编解码器。例如，Web Audio API 和 WebRTC API。但是，这些 API 不允许开发人员使用视频流的单个帧和未复用的编码音频或视频块。

Web 开发人员通常使用 WebAssembly 来绕过此限制，并在浏览器中使用媒体编解码器。但是，这需要额外的带宽来下载浏览器中已经存在的编解码器，从而降低性能和电源效率，并增加额外的开发开销

总结缺点:

- 增加了下载浏览器中已有编解码器的带宽
- 性能降低
- 降低电源效率

* WebAudio 允许将媒体文件（以二进制缓冲区的形式）解码为 PCM，但它必须是有效且完整的媒体文件。它不支持数据流式处理。它不提供进度信息。当然不支持视频，也不支持编码。
* MediaRecorder 允许对具有音频和视频轨道的 MediaStream 进行编码。对某些参数（每秒位数，带有编解码器字符串的 mimetype）有粗略的控制，但它的级别非常高。它不支持快于实时的编码。不适合低延迟编码，因为输出可以缓冲。编码的比特流被包装在容器中，这增加了需要自己的容器格式的用例的开销。许多事情尚不清楚：在运行不足期间会发生什么，当编码速度太慢而无法实时时会发生什么。它非常适合基本用途，但缺少很多功能。
* WebRTC PeerConnection 允许对网络 RTP 流进行编码和解码，并且与其他 WebRTC 和 MediaStream API 具有高度耦合，它不能实际用于其他任何事情。它也非常不透明。JavaScript 无法访问编码的数据。
* HTMLMediaElement 和 Media Source Extension 允许实时解码媒体，同时流式传输压缩数据。视频和音频输出的灵活性很小（画布可用于调整视频，但效率不是很高）。对解码速度的控制很少，唯一的可能性是通过 playbackRate，它将音高补偿应用于音频。没有办法被告知新图像已被解码，也无法提前决定解码多少。没有办法像主机一样快地解码图像数据并对数据运行计算。编码的比特流必须以特定的容器格式提供，这增加了用例的开销，这些用例具有自己的容器格式，而不是浏览器的本机格式。

## 目标

为 Web 应用提供对内置（软件和硬件）媒体编码器和解码器的高效访问，以便对具有以下属性的媒体进行编码和解码：

- 可流性：对数据流进行操作的能力，这些数据流不一定全部在内存中（可能在网络上，可能在磁盘上等）。
- 效率：能够利用主机上可用的 UA，系统和/或硬件，使解码或编码过程更加高效。限制垃圾量（在“垃圾回收”意义上），将 GC 压力限制在最低限度，以避免 GC 带来的固有的非确定性。
- 可组合性：与其他 Web API（如 Streams，WebTransport 和 WebAssembly）配合使用。
- 弹性：在出现问题（网络运行不足、由于资源丢失而导致的丢帧等）时进行恢复的能力
- 灵活性：能够将此 API 用于所有用例（硬实时，软实时，非实时）。可能在顶部实现 MSE 或 WebRTC 之类的东西，具有相同的电池寿命和延迟。
- 对称性：具有相似的编码和解码模式

## 关键用例

- 极低延迟的直播（< 3 秒延迟）
- 云游戏
- 直播上传
- 非实时编码/解码/转码，例如用于本地文件编辑
- 高级实时通信：
  e2e 加密
- 控制缓冲区行为
- 空间和时间可扩展性
- 解码和编码图像
- 重新编码多个输入媒体流，以便将许多编码的媒体流合并为一个编码的媒体流。
