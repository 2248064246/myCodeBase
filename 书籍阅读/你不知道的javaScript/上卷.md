

# 你所不知道的javaScript上卷

[TOC]

## 作用域是什么

### 编译原理
> JS代码的编译发生在代码执行前的几微秒
+ 分词/词法分析
+ 解析/语法分析
  + AST语法树
+ 代码生成
  + 将AST转换为可执行代码

### 理解作用域
> 进行 var a = 2 操作过程来说明

+ 编译器处理过程 (`声明` 和 `赋值`)
  + 编译器会查询作用域中是否已经存在 `a`变量, 如果存在则忽略 `var a` 声明, 不存在则创建 `a` 变量
  + 接下来编译器会生成运行时代码来进行赋值操作, 然后会查找作用域中是否存在 `a`, 存在直接使用这个变量, 不存在会沿着作用域查找

+ 引擎是如何查找变量
  + LHS
    + 赋值查询, 需要将值赋值给变量
  + RHS
    + 取值查询, 只需要拿到变量的值
  + 他们的区别
    + RHS 如果没有找到会抛出 `ReferenceError`, 表示没有该变量的引用(该变量未找到)
    + LHS 如果没有找到, 引擎会自动帮你创建一个(一般是全局变量)
    ```javaScript
      function foo(a) {
        console.log(a + b) // 这里会抛出错误, b没有找到
        b = a // 这里会自动创建一个全局变量 b
      }
      foo(2)
    
    ```
    + RHS 查询中, 找到了, 但是如果尝试对这个变量进行不合理的操作, 例如: 对非函数进行函数调用, 引用 'null, 'undefined' 类型中的属性, 引擎会抛出 `TypeError` 错误

### 词法作用域
> 作用域有两种工作模型: 词法作用域(大多数编译器使用), 动态作用域

+ 什么是词法作用域
  + 词法作用域就是定义在词法阶段的作用域, 是由写代码时变量和块作用域写在哪里来决定的

> 作用域查找

+ 作用域查找会在找到第一个匹配的标识符时停止(逐级向上查找)
+ 遮蔽效应
  + 在多层的嵌套作用域中, 可以定义同名的标识符, 这就会造成 `遮蔽效应`
  + 内部标识符 遮蔽 了外部的标识符
+ 处理遮蔽效应
  + 使用 'window' 全局变量, 可以不直接通过`标识符`来查找, 而是通过 `window.标识符`

> 无论函数在哪里被调用, 也无论被如何调用, 它的词法作用域都只由函数声明时所处的位置决定

> 词法作用域只会查找一级标识, 找到这个变量之后, 对象属性访问规则会接管之后的属性访问

