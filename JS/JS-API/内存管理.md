# 内存管理

JS 是动态语言, 内存的分配在变量创建时自动进行的, 并且在不使用它们的时候进行"自动"释放.

释放过程称为`垃圾回收`.

## 内存生命周期

1. 分配需要的内存
2. 使用分配的内存
3. 不需要时将其释放

## JS 的内存分配

**值的初始化**

JS 在定义变量时就自动完成了内存分配.

**通过函数调用分配内存**

有些函数调用的结果会返回一个变量, 此时会分配内存

## 内存释放

这里最困难的是寻找到那些被分配的内存不在被需要. 对于底层语言(例如: c)来说, 这一点是有程序员受控指定的, 而 JS 是通过一些方法自动进行寻找.

高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。

## 垃圾回收

垃圾回收只能有限的解决一般问题.

**引用**

垃圾回收算法主要依赖于引用的概念. 在内存管理环境中, 一个对象如果有访问另外一个对象的权限(隐式或者显示), 叫做一个对象引用另一个对象.

> Note: 这里`对象`的概念不仅仅指 JS 对象, 还包括函数作用域, 全局作用域等

### 引用计数垃圾收集

这是最初级的垃圾回收算法. 此算法把`对象是否不再被需要`简化定义为`对象没有其他对象引用到它`. 如果没有引用指向该对象(零引用), 对象将被垃圾回收机制回收.

**限制: 循环引用**
此算法有一个限制: 无法处理循环引用. 例如: a 对象中的一个属性引用 b 对象, b 对象中的一个属性引用 a, 此时 a 对象和 b 对象都将无法被回收.

### 标记-清除算法

这个算法把`对象是否不再需要`简化定义为`对象是否可以获得`.

假定设置一个叫做根(root)的对象, 垃圾回收器将定期从根开始, 找所有从根开始引用的对象, 然后找到这些对象引用的对象, 并对内存进行标记... 从根开始, 垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象(这里的收集不可获得对象值的是从引擎自身维护的内存表中进行查找, 那些没有被标记为可获取的对象就是)

**循环引用不在是问题**

`有零引用的对象总是不可获得的`, 但是反过来却不一定.

从 2012 开始, 所有现代浏览器都使用了`标记-清除`垃圾回收算法, 所有对 JS 垃圾回收算法的改进都是基于标记-清除算法的改进.


