
# 值

## 数组

有一个需要特别关注 **如果字符串的值能够被强制类型转换为十进制数字, 它就会被当做索引来处理**
```js
let a = []
a[0] = 0
a['13'] = 13 // 此时数组长度会变成 14
```


## 字符串

**字符串是不可变的**这是一个很重要的特性, 虽然平时体现不是很明显

**字符串也是可迭代的**, 因此可以用数组方法来处理字符串(不是所有的方法都可以用于数组)
```js
let a = 'FOO'
a = Array.prototype.join.call(a, '.') // F.O.O (这里由于字符串不可改变, 所以需要将返回的值重新赋值给 a)
```


字符串逆转 (这里要注意表情字符的处理)

```js
// 普通字符串可以先数组化, 然后 reverse, 再字符串化
let str = 'abcd↓❤😂❤️'
Array.from(str).reverse().join('') // 实际上对于大部分字符串, 这种方法是可以的, 除了最后那个表情处理有点问题, 其他都是OK的

// 这也是 Array.from 比 split 方法好的一点, split 方法是根据一个 `utf-16` 编码来判断, 对于两个`utf-16`长度的特殊字符就区分不出来了


// 要更加准确区分, 请参考 `javascript权威指南/4-类型,值和变量.md`
```


## 数字

+ 数字语法
```js
// 小数点前面的0可以省略
var a = 0.2
var c = .3

// 小数点后面的0也可以省略
var d = 3.0
var e = 4. // 同样是可以的

// 允许使用科学计数法
var f = 1e3
var g = 1E-4 // e 不限制大小写


// 需要注意以下
42.toString() // 报错
42. toString() // 抱错
0.42.toString() // 有效 0.42  (一个数字中只能有一个'.', 所以后面一个'.'被识别为属性访问符)
(42).toString() // 有效 42
42..toString() // 有效 42

/* .运算符在数字中需要特别注意, 因为它同时也是一个有效的数字字符, 会被有效识别为`数字字面量`的一部分, 然后才是对象属性访问符 */
```

+ javaScript 使用的数字类型是基于 `IEEE 7541` 标准来实现的, 该标准通常也被称为`浮点数`, javaScript 使用的是`双精度`格式(即64位二进制)

二进制浮点数的最大问题就是小数并不是十分精确

典型的例子是
```js
  0.1 + 0.2 === 0.3 // false
```

在处理小数的需要特别注意. 

在判断两个数是否想等上, 有一下几个思路
1. 误差判断
2. 转为字符串

+ 误差判断
  JS中的数字误差通常为 `2^-52` (在ES6之后, 直接存储在 Number.EPSILON 中)
  ```js
    function numbersCloseEnoughToEqual(n1, n2) {
      return Math.abs(n1 - n2) < Number.EPSILON
    }
  ``` 

+ 数字的安全范围

能够被安全呈现的最大整数是 `2^53-1`, ES6中定义为`Number.MAX_SAFE_INTEGER`. 最小整数是`-2^53+1`, ES6中定义为`Number.MIN_SAFE_INTEGER`



+ 32 位有符号整数

  JS中有一些操作只适用于32位数字, 例如位操作

```js
 x | 0 可以将变量 x 中的数值转换为32位有符号整数, 其他数位将会被忽略
```

+ 特殊的数字

NaN, 不是数字的数字, 但仍然是数字类型, 也是唯一一个自反的值

关于如何判断一个数是不是NaN
```js
// 在以前使用 window.isNaN, 但是这个方法并不会判断传入的值是否是数字类型
window.isNaN('foo') // true

// 很明显 foo 不是数字类型

// ES6之后, 在Number上增加了一个 isNaN 方法用于修复这个问题
Number.isNaN('foo') // false

```


+ 无穷数

js中 `除以0` 是不会报错的, 而是返回`Infinity`

js中, 任何结果溢出的操作, 都会返回 `Infinity` 或者`-Infinity`

```js
Infinity/Infinity // NaN

0/Infinity // 0

```

+ 零值

js中是有 +0 和 -0 的, 在一般的判断中 `+0==-0` `+0===-0` 是相等的

虽然在绝大多数情况下, 0的正负并不紧要, 但是需要的话可以通过 `Object.is()` 来判断 


