

# 递归

要学习 `树` 和 `图` , 就必须先熟悉递归

## 理解递归

从解决问题的各个小部分开始, 知道解决最初的大问题

每个递归函数都必须要有`基线条件`, 即下一个不在递归的条件(停止点), 以防止无限递归

## 调用栈

每当一个函数被一个算法调用时, 该函数会进入调用栈的顶部.

当使用递归的时候, 每个函数调动都会堆叠在调用栈顶部, 这是因为每个调用都可能依赖前一个调用的结果

## JS 调用栈限制

如果递归无限下去, 浏览器会抛出错误, 这就是栈溢出错误 (stack overflow error)

每个浏览器的限制不同, 大体都小于2万次

## 尾调用优化

尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

**注意**
+ ES6的尾调用优化只在严格模式下开启，正常模式是无效的。
+ 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。
  + arguments
  + caller

尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。

关于严格模式
在函数顶部直接写了 "use strict" ，而该函数拥有以下的参数其中之一：

    默认参数
    剩余参数
    解构赋值

根据ECMAScript规范，不允许在这些函数的顶部使用“use strict”指令。

```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f() 的调用记录，只保留 g(3) 的调用记录。

这就叫做"尾调用优化"（Tail call optimization），即只保留内层函数的调用记录。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用记录只有一项，这将大大节省内存。这就是"尾调用优化"的意义。

如果满足以下条件，尾调用将不再创建新的栈帧，而是清除并且重用当前栈帧。

（1）尾调用不访问当前栈帧的变量（也就是说函数不是一个闭包）

（2）在函数内部，尾调用是最后一条语句

（3）尾调用的结果作为函数值返回

[相关博客](http://www.ruanyifeng.com/blog/2015/04/tail-call.html)


### 尾递归

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。

在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。

### 但是

以上这些都是美好的理论, 它甚至是可行的

但是, 尾调用只是语义上的定义, 如何正确书写尾调用需要你有一定功底

并且, 尾调用优化会导致调用栈丢失

所以, 在具体的是现在各大厂商出现了分歧, 导致现在只有 safari 支持的这个特性

chromium, Gecko, Node 都没有支持尾调用优化的功能

[尾调用依然溢出问题](https://github.com/ruanyf/es6tutorial/issues/703)
[尾递归的后续探究](https://imweb.io/topic/5a244260a192c3b460fce275)
[尾调用优化正确书写](https://2ality.com/2015/06/tail-call-optimization.html#checking_whether_a_function_call_is_in_a_tail_position)