# canvas 中的数学

## 坐标系

canvas 中使用的是 W3C 坐标系(x 轴正方向向右, y 轴方向向下)

## 三角函数

canvas 中设计到角度使用的都是弧度.

`Math.sin(弧度)`
`Math.cos(弧度)`
`Math.tan(弧度)`
`Math.asin(sin值)` 得到对应弧度
`Math.acos()`
`Math.atan()`

### Math.atan() 与 Math.atan2()

这两个都可以用于计算两条边之间的夹角.(最常见的例子就是随鼠标旋转)

但是 Math.atan() 并不能准确知道具体的位置点(一三和二四象限点的正切值相同)

而`Math.atan2(y, x)` 可以准确表示对应的是哪个象限的角

> y: 对边长度(允许带方向); x: 临边长度(允许带方向)

```js
Math.atan2(1, 2); // 约为 26.56°
Math.atan2(-1, -2); // 约为 -153.43°
```

### 两点之间的距离

`Math.sqrt((x2 - x1)^2 + (y2 - y1)^2)`

### 圆周运动 和 椭圆运动

圆的标准方程 `x^2 + y^2 = R^2`

所以圆上任意一点 `x = R*cosɑ` `y = R*sinɑ`

所以可以得到, 在 canvas 中球上点的坐标为

```js
x = x1 + r * Math.cos(angle);
y = y1 + r * Math.sin(angle);
```

椭圆同理

### 波形运动

通过三角函数来实现周期变化

## 匀速直线运动

```js
x += vx;
y += vy;
```

沿着任意方向的匀速直线运动

> 需要使用速度分解, 分解到 x 方向和 y 方向

```
V合 = Math.sqrt(vx^2 + vy^2)`
```

```
vx = V合 * Math.cos(angle * Math.PI/180); angle是角度
vy = V合 * Math.sin(angle * Math.PI/180);
```

## 加速运动

加速运动，指的是方向相同、速度大小变化的运动

> 匀加速和匀减速运动

加速度: a = Δv/Δt

同样, 加速度可以分解为在 x 和 y 轴上的两个加速度

速度公式: `v = V0 + at`;

位移公式: `x = (v0 + Vt)/2*T = V0*t + 1/2aT^2 `

## 摩擦力

其中摩擦力的方向与物体相对运动的方向相反。摩擦力只会改变速度的大小而不会改变运动的方向。换句话说，摩擦力只能将物体的速度降至 0，但它无法让物体往相反的方向运动。

## 边界检测

> 检测物体与边界是否碰撞

## 边界环绕

其中摩擦力的方向与物体相对运动的方向相反。摩擦力只会改变速度的大小而不会改变运动的方向。换句话说，摩擦力只能将物体的速度降至 0，但它无法让物体往相反的方向运动。

## 边界生成

其中摩擦力的方向与物体相对运动的方向相反。摩擦力只会改变速度的大小而不会改变运动的方向。换句话说，摩擦力只能将物体的速度降至 0，但它无法让物体往相反的方向运动。

## 边界反弹

碰到边界后对速度取反

> 在物体碰到边界后，我们需要做两件事：保持它的位置不变；改变它的速度向量。

## 碰撞检测

> 检测物体与物体

### 外接矩形

对于外接矩形判定法，我们一般需要两步：一是“找出物体的外接矩形”，二是“对外接矩形进行碰撞检测”。

```js
window.tools.checkRect = function (rectA, rectB) {
  return !(
    rectA.x + rectA.width < rectB.x ||
    rectB.x + rectB.width < rectA.x ||
    rectA.y + rectA.height < rectB.y ||
    rectB.y + rectB.height < rectA.y
  );
};
```

### 外界圆

判断两个圆是否发生碰撞，我们只需要判断“两个圆心之间的距离”。如果两个圆心之间的距离大于或等于两个圆的半径之和，则两个圆没有发生碰撞；如果两个圆心之间的距离小于两个圆的半径之和，则两个圆发生了碰撞

## 多物体碰撞

### 排列组合

当画布中只有两个物体时，只有一种碰撞情况：A-B。当画布中有 3 个物体时，共有 3 种情况：A-B、A-C、B-C。当画布中有 4 个物体时，共有 6 种情况：A-B、A-C、A-D、B-C、B-D、C-D。依次类推。咦？怎么有点似曾相识的感觉呢？没错，这就是我们高中数学中的排列组合。这里，一定要记住：A-B 与 B-A 是一种情况，同理，A-C 与 C-A 也是一种情况。因为两个物体的碰撞是相互的，你碰我，不就等于我碰你了？所以在计算的时候，不要把这种重复情况加进去。如果有 n 个物体，根据排列组合知识可以知道，此时共有 n×(n-1)/2 种碰撞情况，计算过程如下。(n - 1) + (n - 2) +…+ 1=(n - 1 + 1) × (n -1 ) / 2= `n × (n -1)/2`

```js
balls.forEach(function (ballA, i) {
  /* 重要的是这里的 j = i + 1, 跳过前面的 */
  for (var j = i + 1; balls.length; j++) {
    var ballB = balls[j];
    if (tools.checkCircle(ballA, ballB)) {
    }
  }
});
```

## 高级动画

### 缓动动画

在 Canvas 中，我们想要实现缓动动画，一般需要以下 5 步。
① 定义一个 0~1 的缓动系数 easing。
② 计算出物体与终点之间的距离。
③ 计算出当前速度，其中当前速度=距离 × 缓动系数。
④ 计算新的位置，其中新的位置=当前位置+当前速度。
⑤ 重复执行第 ②~④ 步，直到物体达到目标。

### 弹性动画

在弹性动画中，跟距离成正比的是加速度。物体离终点越远，加速度越大。刚开始时，由于加速度的影响，速度会快速增大。当物体接近终点时，加速度变得很小，但是它还在加速运动。由于加速度的影响，物体会越过终点。然后随着距离的变大，反向加速度也随之变大，这就会把物体拉回来。物体在终点附近来回反弹一会儿，最终在摩擦力的作用下停止。

```js
ax = (targetX - object.x) * spring;
ay = (targetY - object.y) * spring;
vx += ax;
vy += ay;
vx *= friction;
vy *= friction;
object.x += vx;
object.y += vy;
```


