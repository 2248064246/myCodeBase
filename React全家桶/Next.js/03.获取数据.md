# 获取数据

- `getStaticProps` 用于静态生成, 在构建时生成数据
- `getStaticPaths` 用于静态生成, 生成动态路由
- `getServerSideProps` 用于服务端渲染获取数据

## getStaticProps

```js
export async function getStaticProps(context) {
  return {
    // 返回这个props将被作为组件的props参数传入
    props: {}, // will be passed to the page component as props
  };
}
```

`context` 对象包含下列属性:

- `params` 包含动态路由的页面的路由参数, 一般来说是类如 `{id: xxx}` 这种.(如果页面名称是`[id].js`)
- `preview` 为`true`表示页面处于预览模式.
- `previewData` 包含由设置的预览数据`setPreviewData`
- `locale` 包含语言环境
- `locales` 包含所有受支持的语言环境(如果启用了国际化路由)
- `defaultLocale` 包含配置的默认语言环境

`getStaticProps` 应该返回一个对象

- `props` 一个可选对象, 将返回格页面组件
- `revalidate`
- `notFound` 一个可选布尔值, 允许页面返回 404 状态和页面

  ```js
  export async function getStaticProps(context) {
    const res = await fetch(`https://.../data`);
    const data = await res.json();

    if (!data) {
      return {
        notFound: true,
      };
    }

    return {
      props: { data }, // will be passed to the page component as props
    };
  }
  ```

- `redirect` 一个可选的重定向值, 允许重定向到内部和外部资源. 应该使用如下对象形式`{destination: string, permanent: boolean}

  ```js
  export async function getStaticProps(context) {
    const res = await fetch(`https://...`);
    const data = await res.json();

    if (!data) {
      return {
        redirect: {
          destination: '/',
          permanent: false,
        },
      };
    }

    return {
      props: { data }, // will be passed to the page component as props
    };
  }
  ```

### 增量静态再生

Next.js 允许在构建网站后创建或更新静态页面. 增量静态重新生成能够在每页的基础上使用静态生成, **而无需重建整个站点**

通过在`getStaticProps` 方法中返回带有`revalidate`属性的对象来开启增量静态再生成

```js
function Blog({ posts }) {
  return (
    <ul>
      {posts.map((post) => (
        <li>{post.title}</li>
      ))}
    </ul>
  );
}
export async function getStaticProps() {
  const res = await fetch('https://.../posts');
  const posts = await res.json();
  return {
    props: {
      posts,
    },
    // Nextjs 会重新将会重新构建页面
    // - 当一个新请求进入
    // - 并且10秒内只生效一次
    revalidate: 10, // In seconds
  };
}

export async function getStaticPaths() {
  const res = await fetch('https://.../posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id },
  }));

  // `fallback: 'blocking'
  // 当请求的路径不存在是, 将会使用server-render来构建这个页面
  // 并缓存下来用于下次访问
  return { paths, fallback: 'blocking' };
}

export default Blog;
```

