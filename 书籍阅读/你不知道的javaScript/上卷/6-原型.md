
# 原型

## 原型赋值时候的屏蔽现象

例如我没给一个对象赋值`myObject.bar = 'foo'`, 会有以下三种情况

1. 如果在原型链上层存在`bar`属性, 且是普通属性, 则会在 `myObject` 上创建一个 `bar` 属性, 并赋值
2. 如果在原型链上存在`writable: false` 的`bar`属性, 则赋值会失败, 在严格模式下还会抛出错误
3. 如果在原型链上存在一个 bar 的 `setter`, 那就一定会调用这个setter, `bar` 不会被添加到`myObject`

> 第二种情况最让人意外, 只读属性会阻止链下层隐式创建同名属性

> 更奇怪的是, 这个限制只发生在 `=` 赋值, 使用`Object.defineProperty()` 并不会收到影响


示例二
```js
var aObj = {a: 1}
var bObj = Object.create(aObj)

bObj.a++

aObj.a // 1 (没想到吧)
bObj.a // 2 
```
首先 `bObj.a++` 等同于 `bObj.a = bObj.a + 1`, 先从原型链获取值, 然后再在`bObj`上创建`a`属性并赋值


