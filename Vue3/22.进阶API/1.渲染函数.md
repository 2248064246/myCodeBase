# 渲染函数

## h()

创建虚拟 DOM 节点

```ts
// 完整参数签名
function h(
  type: string | Component,
  props?: object | null,
  children?: Children | Slot | Slots
): VNode;

// 省略 props
function h(type: string | Component, children?: Children | Slot): VNode;

type Children = string | number | boolean | VNode | null | Children[];

type Slot = () => Children;

type Slots = { [name: string]: Slot };
```

**创建原生元素**

```js
import { h } from 'vue';

// 除了 type 外，其他参数都是可选的
h('div');
h('div', { id: 'foo' });

// attribute 和 property 都可以用于 prop
// Vue 会自动选择正确的方式来分配它
h('div', { class: 'bar', innerHTML: 'hello' });

// class 与 style 可以像在模板中一样
// 用数组或对象的形式书写
h('div', { class: [foo, { bar }], style: { color: 'red' } });

// 事件监听器应以 onXxx 的形式书写
h('div', { onClick: () => {} });

// children 可以是一个字符串
h('div', { id: 'foo' }, 'hello');

// 没有 prop 时可以省略不写
h('div', 'hello');
h('div', [h('span', 'hello')]);

// children 数组可以同时包含 vnode 和字符串
h('div', ['hello', h('span', 'hello')]);
```

**创建组件**

```js
import Foo from './Foo.vue';

// 传递 prop
h(Foo, {
  // 等价于 some-prop="hello"
  someProp: 'hello',
  // 等价于 @update="() => {}"
  onUpdate: () => {},
});

// 传递单个默认插槽
h(Foo, () => 'default slot');

// 传递具名插槽
// 注意，需要使用 `null` 来避免
// 插槽对象被当作是 prop
h(MyComponent, null, {
  default: () => 'default slot',
  foo: () => h('div', 'foo'),
  bar: () => [h('span', 'one'), h('span', 'two')],
});
```

如果一开始并不清楚组件的名称, 而是需要根据情况动态渲染不同的组件, 需要使用 `resolveComponent()` 来解析组件名称

## resolveComponent()

按名称手动解析已注册的组件。

```ts
function resolveComponent(name: string): Component | string;
```

```js
const { h, resolveComponent } = Vue;

export default {
  render() {
    const ButtonCounter = resolveComponent('ButtonCounter');
    return h(ButtonCounter);
  },
};
```

## mergeProps()

合并多个 props 对象, 用于处理含有特定 `props` 参数的情况

```ts
function mergeProps(...args: object[]): object;
```

支持以下特定 props 参数处理:

- class
- style
- onXxx 事件监听器

```js
import { mergeProps } from 'vue';

const one = {
  class: 'foo',
  onClick: handlerA,
};

const two = {
  class: { bar: true },
  onClick: handlerB,
};

const merged = mergeProps(one, two);
/**
 {
   class: 'foo bar',
   onClick: [handlerA, handlerB]
 }
 */
```

## cloneVNode()

```ts
function cloneVNode(vnode: VNode, extraProps?: object): VNode;
```

克隆一个 VNode, 并可以添加额外的 props

## isVNode()

判断一个对象是不是 VNode

## resolveDirective()

```ts
function resolveDirective(name: string): Directive | undefined;
```

按名称解析已经注册的指定

## withDirectives()

用于给 VNode 增加自定指令

```ts
function withDirectives(vnode: VNode, directives: DirectiveArguments): VNode;

// [Directive, value, argument, modifiers]
type DirectiveArguments = Array<
  | [Directive]
  | [Directive, any]
  | [Directive, any, string]
  | [Directive, any, string, DirectiveModifiers]
>;
```

`[Directive, value, argument, modifiers] `

```js
import { h, withDirectives } from 'vue';

// 一个自定义指令
const pin = {
  mounted() {
    /* ... */
  },
  updated() {
    /* ... */
  },
};

// <div v-pin:top.animate="200"></div>
const vnode = withDirectives(h('div'), [[pin, 200, 'top', { animate: true }]]);
```

## withModifiers()

用于向事件处理函数添加内置`修饰符`

```ts
function withModifiers(fn: Function, modifiers: string[]): Function;
```

```ts
import { h, withModifiers } from 'vue';

const vnode = h('button', {
  // 等价于 v-on.stop.prevent
  onClick: withModifiers(() => {
    // ...
  }, ['stop', 'prevent']),
});
```


