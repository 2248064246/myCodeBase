## 可读流

### 构造函数

ReadableStream() 创建并从给定的 Handler 返回一个可读流对象。

```js
new ReadableSteam(underlyingSource, queuingStrategy);
```

### 参数

**underlyingSource** 底层源
一个对象, 包含一些方法属性, 用于控制流行为.

- `start(controller)` 当可读流被创建的时候立即调用, 参数是当前可读流的控制器. 可以返回一个 promise 用于执行异步操作, 如果 promise 返回 reject, 则流会抛出错误.
- `pull(controller)` 会反复执行, 知道流达到设置的高位标志. 可以返回一个 promise, 只有 promise 返回 resolve, 才会执行下一次 pull.
- `cancel(reason)` 当流被取消的时候调用, 参数 reason 是取消时传入的描述
- `type`

**quenuingStrategy** 排队策略
一个对象, 用于控制流中的队列

- `highWaterMark` 一个非负整数--定义了流队列中最多能够包含的`chunk`数量
- `size(chunk)` 它应该返回该 chunk 的字节大小

> Note: 应该自己设置 highWaterMark 的属性值, 默认情况下它是 '1';

> Note: quenuingStrategy 对象可以通过 ByteLengthQueuingStrategy 或者 CountQueuingStrategy 构造函数创建

```js
const queueingStrategy = new CountQueuingStrategy({ highWaterMark: 1 });
// or
const queueingStrategy = new ByteLengthQueuingStrategy({ highWaterMark: 1 });
```

### 可读流控制器

**ReadableStreamDefaultController** 默认可读流控制器

+ `desiredSize` 返回填充流内部队列所需要的大小(就是流内部队列的剩余空间)
+ `close()`
+ `enqueue(chunk)` 将给定的chunk排入流队列
+ `error(e)` 抛出一个错误, 可以多次调用

### 属性

locked 表示这个可读流是否被读取器锁定

### 方法

- `cancel()` 取消读取流, 可以传入 reason 参数表示取消原因, 这个原因将传给调用方
- `getReader()` 创建一个读取器并将流锁定于其上, 其他读取器将不能读取这个流, 直到它被释放
- `getIterator()` 创建一个异步的 ReadableStream 迭代器并将流锁定于其上。一旦流被锁定，其他读取器将不能读取它，直到它被释放。
- `pipeThrough(transformStream)` 提供将当前流管道输出到一个 transform流对的链式方法. 返回 transformStream 的可读流
- `pipeTo(ritableStream)` 将当前 ReadableStream 管道输出到给定的 WritableStream，并返回一个 promise，输出过程成功时返回 fulfilled，在发生错误时返回 rejected。
- `tee()` tee 方法（tee 本意是将高尔夫球放置在球座上）tees 了可读流，返回包含两个 ReadableStream 实例分支的数组，每个元素接收了相同的传输数据。

## ReadableStreamDefaultReader

流数据的一个默认读取器

### 构造方法

`ReadableStreamDefaultReader(readableStream)` 创建和返回一个读取器对象实例

### 属性

- `closed` 得到一个promise. 如果这个 stream 变成关闭状态或者 reader 的锁(lock)被释放 则返回一个状态是 fulfills 的 promise,如果这个 stream 报错则返回 rejects 的 promise

### 方法

- `cancel()` 取消这个 stream, 表示对这个 stream 失去了兴趣. 提供的参数将传递给源 source, 可能会也可能不会用到这些参数.
- `read()` 返回一个 promise,提供对 stream 内部队列中下一个块(chunk)访问的 promise. 
  - 如果chunk有效, 则返回值是 `{value: theChunk, done: false}`
  - 如果流被关闭了, 则返回值是 `{value: undefined, done: true}`
  - 如果流抛出错误, 则返回 reject
- `releaseLock()` 释放读取这个 stream 的锁
