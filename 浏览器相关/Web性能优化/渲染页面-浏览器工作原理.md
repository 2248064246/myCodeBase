
# 渲染页面--浏览器工作原理

[toc]

## 概述

等待资源加载和JS的单线程执行时影响 Web性能的主要因素

## 导航

导航是加载 Web 页面的第一步. 一下情况触发导航: 在地址栏输入 url 并 enter, 点击一个链接, 提交一个表单, JS 代码调用 Widow.open API 或者其他

### DNS 查找

导航的第一步是去寻找页面资源位置

浏览器通过服务器名称请求DNS查找, 最终返回一个ip地址

如果 js, img, font 等资源的主机地址不通, 也需要请求 DNS

DNS 对于性能来说是一个问题, 尤其是移动网络(需要经过信号塔 - 运行商 - DNS)

+ DNS 查询原理
  + 先查找根域名服务器
  + 通过根域名服务器查找二级域名
  + ....
+ DNS 缓存 
  + 浏览器缓存
  + host缓存
  + 路由器缓存
+ DNS 预获取
  + `rel属性`的 `dns-prefetch` 可以预先获取 DNS
  ```html
    <link rel="dns-prefetch" href="https://fonts.googleapis.com/"> 
  ```

  + 注意
    1. 只能针对不同站点的跨域资源

### TCP 连接

获取了IP地址之后, 浏览器就会通过 TCP 与服务器建立连接

+ TCP 三次握手, 四次挥手

+ 为什么是三次握手四次挥手
  + 断开连接的时候, 客户端发送断开请求, 服务端返回确认信息, 服务端发送断开请求, 客户端发送确认信息
  + 关键点在于, 客户端发送断开请求时, 服务端可能还在发送数据给客户端, 只有数据发送完了, 服务端才会发送断开请求给客户端

### TLS 协商

为了在 HTTPS 上建立安全连接, TLS 是必须得, 协商服务器和客户端使用什么加密解密方法

## 响应

一旦与服务器连接, 浏览器就发送了一个初始 http get 请求, 对网站来说通常是 HTML 文件

### TCP慢开始 / 14kb 规则

第一个响应包是 14kb 大小. 这是慢开始的一部分, 慢开始是一种均衡网络连接速度的算法.

慢开始逐渐增加发送数据的数量, 直到达到网络的最大带宽

### 拥塞控制

当服务器用TCP包来发送数据时，客户端通过返回确认帧来确认传输。由于硬件和网络条件，连接的容量是有限的。 如果服务器太快地发送太多的包，它们可能会被丢弃。意味着，将不会有确认帧的返回。服务器把它们当做确认帧丢失。拥塞控制算法使用这个发送包和确认帧流来确定发送速率。

### IP 寻址

### ARP 和 RARP

## 缓存和资源有效期

### 浏览器缓存

如果请求的资源被浏览器缓存了, 并且在有效期内, 则直接使用缓存资源, 否则会发送请求给后端

### 资源有效期

客户端请求一个有效期过期的资源时, 后端会对比一次该资源是否修改, 如果位修改则返回 304, 否则放回新的资源

## 解析

一旦浏览器收到数据的第一块, 它就可以开始解析收到的信息. 

解析是指: 将接收到的数据转为 DOM 和 CSSOM 的步骤, 通过渲染器把 DOM 和 CSSOM 绘制到屏幕上

即使请求页面的 HTML 大于初始的 14kb, 浏览器也将开始解析并尝试根据其拥有的数据进行渲染

保证第一个渲染的 HTML 小于 14kb 是重要的

但是在渲染到屏幕上之前, HTML CSS JavaScript 必须被解析完成

### 构建DOM输

第一步处理 HTML 标记并构造DOM树, 包括开始和结束标记, 属性名和值. 良好的文档格式, 能够加快解析

DOM 树描述了文档的内容,  html 标签是第一个标签也是文档树根节点. 树反映了不同标记之间的关系和层次结构

当遇到 script (没有表明 sync 或 defer)时, 会阻塞渲染并停止 HTML 解析

等待获取 CSS不会阻塞HTML的解析, 但是它会阻塞 JavaScript, 因为 JavaScript可能需要查询元素的CSS属性


### 预加载扫描器

浏览器构建DOM树时, 这个过程占用了主线程. 这时预加载扫描器将解析可用的内容并请求高优先级资源(JS, CSS, 字体), 它将在后台检索资源, 以便主 HTML 解析器到达请求资源师, 资源已经在下载或者已经准备好了

### 构建CSSOM树

第二步是处理 CSS 并构建 CSSOM 树, 浏览器将CSS规则转换为可以理解和使用的样式映射

构建 CSSOM 非常非常快

CSSOM 是阻塞的, 浏览器会阻塞页面渲染知道接收和执行了所有的css, 因为 CSS规则是可以被覆盖的


### 其他过程

+ JavaScript 编译

+ 构建辅助功能树 -- 可访问性对象模型(AOM)

## 渲染

渲染步骤包括样式, 布局, 绘制, 某些情况下还包括合成, CSSOM 和 DOM 树组合成 render 树, 用于计算每个可见元素的布局(render树中没有不可见元素)

某些情况下, 可以将内容提升到它们自己的层并进行合成, 通过GPU来绘制提高性能


### Style

第三步是将 DOM 和 CSSOM 合成render树

任何具有 `display: none` 的标签将不会出现在 render 树上, 具有 `visibility: hidden` 的节点会出现在 render 树上, 因为它们会占用空间

每个可见节点都应用了其CSSOM规则, Render 树保存所有具有内容和计算样式的可见节点

### Layout

第四步是在渲染树上运行布局以计算每个节点的几何体.

布局是确定render树中所有节点宽高, 位置, 以及确定页面上每个对象的大小和位置的过程

回流是对节点大小和位置的重新计算

重绘是对不会影响元素位置和大小的属性重新计算

渲染树标识显示那些节点及其计算样式, 但是不标识每个节点的尺寸位置, 为了确定整个, 浏览器从渲染树根节点开始遍历

### Paint

最后一步是将各个节点会知道屏幕上

绘画包括将元素的每个可视部分绘制到屏幕上, 包括文本, 颜色, 边框, 阴影等等

为了确保平滑滚动和动画, 主线程所有内容, 包括计算样式, 绘制, 必须让浏览器在 16.7ms 内完成

为了确保重绘速度比初始绘制的速度更快, 屏幕上的绘图通常被分解成数层(需要进行合成)

绘制可以将布局树中的元素分解为多个层。将内容提升到GPU上的层（而不是CPU上的主线程）可以提高绘制和重新绘制性能

`video` 和 `canvas` 标签可以实例化一个层

`opacity` `3D转换` `will-change` CSS属性可以实例化一个层, 这些节点与子节点一起绘制到它们的层上

层确实可以提高性能, 但是它以内存管理为代价

### Compositing 合成 

当文档各个部分以不同的层绘制, 相互重叠时, 必须进行合成, 以确保它们以正确的顺序绘制到屏幕上

回流会触发重新绘制和重新组合

如果定义了图像大小, 就不需要重新绘制, 只需要重新合成

如果没有, 渲染过程从布局那里开始


## 交互

并非页面加载之后就可以交互, 如果在 onload之后执行大量JS,则会阻塞主线程, 此时无法滚动, 触摸, 及其他交互

