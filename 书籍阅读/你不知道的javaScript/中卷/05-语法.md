# 语法

## 语法和词法

作者说的我不太理解

简单来说: 词法就是一个个的单词, 语法就是单词的组合

## 语句和表达式

语句相当于句子, 表达式相当于短语, 语句可以是一个表达式

## 语句结果值

语句都有一个结果值

获得结果值的最简单方式是在浏览器开发控制台中输入语句, 浏览器控制台会显示最后一条语句执行的结果值

例如 `var a = 3`, 控制台会显示 var 的返回值`undefined` (规范定义 var 的结果值是 undefined)

在代码块中`{...}`, 它的结果是最后一个语句的的结果

> 通常情况下我们拿不到这种的返回值, 语法不允许我们获得语句的结果值并赋值给另一个变量

**但是, 可以通过 eval(...)执行语句并返回**

```js
let a = eval('{3+5}'); // a: 8
```

> 由于 eval 的特性, 最好不要在开发中使用

## 表达式的副作用

最典型的就是 `a++` 了

## 上下文规则

JSON 是 js 的一个子集, 但是 JSON 本身不是合法的 Js 语法

JSON-P: 将 JSON 数据封装为函数调用, 通过将 JSON 数据传递给函数来实现对其访问

这里有个坑

```js
{}+[]; // 0
// 这里第一个 {} 是代码块, 并不是对象...
// 这个代码块不进行任何操作, 最终执行的 +[] 操作, 返回 0
// 真的是要吐...
```

## 纠错机制

ASI: 自动分号插入. JS 中之所以不需要行位的 `;`, 就是因为有这么个东西存在

## 提前使用变量

JS 中 var 和 function 都会造成变量提升

而 ES6 中规定一个新概念--暂时性死区(代码变量还没有初始化而不能被引用的情况)

这也就是 `let`, `const` 申明的变量无法在其使用的原因

## 函数参数

ES6允许定义函数默认值
```js
// 下面这个函数是允许的
function foo(a = 42, b = a + 1) {} 

```
**有一个点要特别注意, 默认参数无法被 arguments 获取**
```js
function foo(a = 42, b = a + 1) {
  console.log(arguments.length)
} 

foo() // 0 此时参数的值是默认值, 但是arguments无法获取到
foo(1) // 1

```
> arguments 数组中的对应单元会和命名参数建立关联, 以得到相同的值. 相反, 不传递参数就不会建立关联

## try...finally

这里我们讨论在 try中return出去一个值, finally中的代码还会执行吗?

```js
function foo () {
  try{
    return 43
  }finally {
    console.log('hello')
  }
  console.log('runs')
}

foo() 
// 结果是:
// hello
// 43

// runs 没有被执行

```
try...cath 中即便有return 值, 也会先执行 finally 中值, 而且如果finally中抛出了错误, 则return值会被抛弃

try...catch 中对于 break 和 continue 也是一样

> 最好的做法是, 不要在 try 中 return


