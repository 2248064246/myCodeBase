
# 类型, 值 和变量

## 数值

JS 使用 IEEE 754 标准定义 64 位浮点格式表示数值 (在表示浮点数的时候会有问题)

### 指数计数法

```js
1.4E2 // => 142

```

### 数字字面量中的分隔符

在 ES2020 之后, 可以使用下划线将数字字面量分隔为更容易看清的数字段

```js
let num = 1_000_000_001 // => 1000000001
let num2 = 1_1_1_01 // => 11101

```

### 算术

JS 中的算术遇到 上溢出, 下溢出, 除以0 时, 不会发生错误

在数值超过最大可表示数时, 结果是一个 `Infinity` 无穷值

同样, 如果是个负值, 结果是 `-Infinity`

JS 中 下溢出会表示为 0, 或者`-0`

### 二进制浮点数与舍入错误

IEEE 754 是一种二进制表示法, 可以精确表示 1/2, 1/8 这种分数

无法准确表示十进制分数(例如: 0.1)

### 通过 BigInt 表示任意精度整数

ES2020 定义的新数据类型

主要为了表示 64位整数(不适合加密, 没有考虑防止时序攻击??)

+ 时序攻击
  `某个函数负责比较用户输入的密码和存放在系统内密码是否相同，如果该函数是从第一位开始比较，发现不同就立即返回，那么通过计算返回的速度就知道了大概是哪一位开始不同的`

```js
1234n
0b11110n // => 二进制BigInt => 30n
0o777n // => 8进制BigInt => 511n
0xabn // => 16进制BigInt => 171n
```

## 文本

字符串是16位值的不可修改的有序序列, 每个值都表示一个 Unicode 字符, length 包含的16位值的个数

### 字符, 码点和 JS字符串

JS 使用的 Unicode 使用的是 UTF-16 编码的

最常用的 Unicode 字符的码点是16位的, 如果超出16位, 则编码为两个16位序列

**意味着, 存在一个长度为2的字符串, 但是只显示一个字符**

```js
let c = '❤️😂' // c.length == 4

// js字符串操作方法一般是操作 16位值, 而不是字符
c[0]  // "❤"
c[1] // ''

// ES6 以后, 字符串也可以迭代, 使用 for/of 或者 ...操作符, 迭代的是字符, 而不是16位值 (这句话有点不大适用, 有问题啊...)

for(const value of c) {
  console.log(value) // => '❤', '', '😂'
}
```

如何只通过字符来判断表情字符长度?? (一种方法是, 将字符存入数组, 但是关键点在于如何正确截取到字符)

```js
let rsAstralRange = '\\ud800-\\udfff',
  rsZWJ = '\\u200d',
  rsVarRange = '\\ufe0e\\ufe0f',
  rsComboMarksRange = '\\u0300-\\u036f',
  reComboHalfMarksRange = '\\ufe20-\\ufe2f',
  rsComboSymbolsRange = '\\u20d0-\\u20ff',
  rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
let reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

let rsFitz = '\\ud83c[\\udffb-\\udfff]',
  rsOptVar = '[' + rsVarRange + ']?',
  rsCombo = '[' + rsComboRange + ']',
  rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
  reOptMod = rsModifier + '?',
  rsAstral = '[' + rsAstralRange + ']',
  rsNonAstral = '[^' + rsAstralRange + ']',
  rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
  rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
  rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
  rsSeq = rsOptVar + reOptMod + rsOptJoin,
  rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
let reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

function toArray(val) { // 字符串转成数组
  return hasUnicode(val) ?
    unicodeToArray(val) :
    asciiToArray(val);
}

function hasUnicode(val) {
  return reHasUnicode.test(val);
}

function unicodeToArray(val) {
  return val.match(reUnicode) || [];
}

function asciiToArray(val) {
  return val.split('');
}
```





