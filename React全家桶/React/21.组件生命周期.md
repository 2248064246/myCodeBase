# 组件生命周期

**挂载**

`constructor(props)`

如果不初始化 state 或不进行方法绑定, 则不需要为 React 组件实现构造函数

通常，在 React 中，构造函数仅用于以下两种情况：

- 通过给 this.state 赋值对象来初始化内部 state。
- 为事件处理函数绑定实例

在 constructor 中需要调用 `super(props)`, 否则可能会出现 `this.props` 未定义的 bug
在 constructor() 函数中不要调用 setState() 方法。应该是直接给 state 赋予初始值.

注意: 避免将 `props`的值复制给`state`(此时 更新 props 中的 color 时, 并不会影响 state). 只要在刻意忽略更新的情况下使用, 此时应该将 prop 命名加上特殊前缀用以区分.(例如: initialColor)

`static getDerivedStateFromProps()`
`render()`

render 方法是 class 组件中唯一必须实现的方法.

当 render 被调用时, 它会检查 this.props 和 this.state 的变化并返回以下类型之一:

- `react元素`
- `数组或者fragments` 使得 render 方法可以返回多个元素
- `Portals` 可以将内容渲染到其他 DOM 中
- `字符串或者数值` 渲染为文本节点
- `布尔值或者null` 什么都不渲染(主要用于支持 `boolean && <Child/>` 这种模式.)

render 函数应该为纯函数, 在里面不应该修改组件的 state 状态.

`componentDidMount()`

会在组件挂载后立即调用. 依赖于 DOM 节点的初始化应该放在这里. 如需通过网络请求获取数据，此处是实例化请求的好地方.

可以在这里直接调用 setState(), 它将触发额外渲染, 但是此渲染会发生在浏览器更新屏幕之前. 如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。

**更新**
`static getDerivedStateFromProps(props, state)`
getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。

此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。

`shouldComponentUpdate(nextProps, nextState)`

根据此方法的返回值, 判断 react 组件的输出是否受当前 state 或 props 更改的影响. 默认行为是 state 每次发生变化组件都会重新渲染.

当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。**首次渲染或使用 forceUpdate() 时不会调用该方法。**

此方法仅作为性能优化的方式而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。

如果你一定要手动编写此函数，可以将 this.props 与 nextProps 以及 this.state 与 nextState 进行比较，并返回 false 以告知 React 可以跳过更新。请注意，返回 false 并不会阻止子组件在 state 更改时重新渲染。

我们不建议在 shouldComponentUpdate() 中进行深层比较或使用 JSON.stringify()。这样非常影响效率，且会损害性能。

`render()`
`getSnapshotBeforeUpdate(prevProps, prevState)`

getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。

`componentDidUpdate(prevProps, prevState, snapshot)`

会在组件更新后立即调用, 首次渲染不会执行此方法.

当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。

也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。

**卸载**
`componentWillUnmount()`

会在组件卸载及销毁之前直接调用. 在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等.

此方法中不应该调用 `setState()`, 因为该组件将永远不会重新渲染

**错误处理**
`static getDerivedStateFromError(error)`
此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state


`componentDidCatch(error, info)`
此生命周期在后代组件抛出错误后被调用。 它接收两个参数：

1. error 抛出的错误信息
2. info 带有组件stack的对象, 包含引起错误的组件栈信息

一般在此方法里面记录错误信息.


## 其他API

`setState(updater, [callback])`

setState() 并不会立即更新组件, 它会批量推迟更新. 

这使得在调用setState() 后立即读取 `this.state` 成为隐患. 为了消除隐患, 请使用 `componentDidUpdate` 或 `setState` 的回调函数这两种方式来保证在应用更新后触发.

除非 shouldComponentUpdate() 返回 false，否则 setState() 将始终执行重新渲染操作。


updater 可以是函数, 也可是对象

形式参数的 updater 函数：
```js
this.setState((state, props) => {
  return {counter: state.counter + props.step};
});
```

对象形式

```js
this.setState({quantity: 2})
```


## forceUpdate()

```js
component.forceUpdate(callback)
```

默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 render() 方法依赖于其他数据，则可以调用 forceUpdate() 强制让组件重新渲染。

调用 forceUpdate() 将致使组件调用 render() 方法，此操作会跳过该组件的 shouldComponentUpdate()。但其子组件会触发正常的生命周期方法，包括 shouldComponentUpdate() 方法。