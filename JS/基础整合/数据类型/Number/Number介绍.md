# Number

第一点也是最终要的一点: JS 使用 [IEEE 754](https://en.wikipedia.org/wiki/Floating-point_arithmetic)标准定义的`双精度浮点类型`(即 64 位二进制)表示数值

这个数据类型能够安全存储 `-(2^53 - 1) 到 2^53 - 1` 之间的数值（包含边界值）

> 这也是 `Number.MAX_SAFE_INTEGER` 和 `number.MIN_SAFE_INTEGER` 表示的值

这是一种二进制表示法, 可以精确表示 `1/2` `1/8` 这种分数, 但是无法准确表示诸如十进制分数(例如 0.1)

典型的例子是:

```js
0.1 + 0.2 === 0.3; // false
```

> 这个的解决方法是使用 Number.EPSILON 来判断两个数的差值

```js
function isEqual(a, b) {
  return Math.abs(a - b) < Number.EPSILON;
}
```

还有一个点, js 中数值是带符号的, 也就是说 `+0` 和 `-0` 是有意义的. 尽管在大多数时候他们被判断为等同. (+0 === -0 返回 true)

如果 `x===y` `1/x` 并不一定等于 `1/y`. 原因是 `1/+0` 是正的 Infinity, 而 `1/-0` 是负的 Infinity

## 数字表示

- 指数计数(E, e 没有区别)

```js
1.4e3; // 1400
1.4e3; // 1400
```

- 数字分隔符 | ES2020+

> 这是为了更好的看清数字

```js
1_111_123; // 等同 1111123
```

- 进制数
  > 特别注意二进制, 八进制, 16 进制数

```js
0123; // 八进制数
0x123; // 十六进制数
0b0101; // 二进制数 (无符号的二进制)
```

以 `数字0` 开头的是八进制数, `0x` 开头是 16 进制, `0b` 是二进制数

Number 原型上的 `toString(base)` 可以指定将当前数转为对应进制数的字符串形式

> 注意: 这个方法将负数转为二进制时, 并不会转为补码形式, 而是先求其绝对值的二进制, 然后在前面加上 `-`号
> 可以理解为 JS 中的二进制是无符号的

```js
(-8).toString(2); // -1000
```

## NaN, Infinity, -Infinity

在 Number.MAX_VALUE 中存储 js 能够表示的最大数值, 超过这个数值的将被转为 Infinity(负数同理)

NaN 表示这不是一个数字, 但是注意这是一个 Number 类型值

```js
typeof NaN; // number
```

## bigInt | ES2020+

这是JS最近新推出的类型, 只在结局js无法准确计算超大值的情况


## 一些特殊说明

```js
(12).toString();
```

上面这个能够运行的原因是: `.` 操作符合 `12` 之间有空格, 所以没有被识别为小数点, 而是认为是点操作符(成员访问符). 此时 js 会将前面的 `12` 包裹为对象
