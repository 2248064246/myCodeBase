# 响应式 API -- 进阶

## shallowRef()

`ref()` 的浅层作用形式

`shallowRef()` 会将内部值原样存储和暴露, 并且不会深层递归地转为响应式. 只有对最外层的访问和修改是响应式的

```js
const state = shallowRef({ count: 1 });

// 不会触发更改
state.value.count = 2;

// 会触发更改
state.value = { count: 2 };
```

作用:

1. 减少大型不可变结构的相应性开销
2. 与其他状态系统集成

## triggerRef()

强制触发一个浅层 ref 的副作用, **通常在对浅引用的内部值进行深度变更后使用**

```js
const shallow = shallowRef({
  greet: 'Hello, world',
});

// 触发该副作用第一次应该会打印 "Hello, world"
watchEffect(() => {
  console.log(shallow.value.greet);
});

// 这次变更不应触发副作用，因为这个 ref 是浅层的
shallow.value.greet = 'Hello, universe';

// 打印 "Hello, universe"
triggerRef(shallow);
```

## customRef()

创建一个自定义的 ref, 显示声明对其以来追踪和更新出发的控制方式

接收一个工厂函数, 参数是 `track` 和 `trigger` 两个函数, 并返回一个带有 `get` 和 `set` 方法的对象

一般来说，track() 应该在 get() 方法中调用，而 trigger() 应该在 set() 中调用. 但是这也可以完全由自己控制

```js
import { customRef } from 'vue';

// 创建一个防抖的 ref
export function useDebouncedRef(value, delay = 200) {
  let timeout;
  return customRef((track, trigger) => {
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          value = newValue;
          trigger();
        }, delay);
      },
    };
  });
}
```

```html
<script setup>
  import { useDebouncedRef } from './debouncedRef';
  const text = useDebouncedRef('hello');
</script>

<template>
  <input v-model="text" />
</template>
```

## shallowReactive()

没有深层转换: 一个浅层响应式对象里只有根级别的属性是响应式的。属性的值会被原样存储和暴露，这也意味着值为 ref 的属性不会被自动解包了。

```js
const state = shallowReactive({
  foo: 1,
  nested: {
    bar: 2,
  },
});

// 更改状态自身的属性是响应式的
state.foo++;

// ...但下层嵌套对象不会被转为响应式
isReactive(state.nested); // false

// 不是响应式的
state.nested.bar++;
```

## shallowReadonly()

没有深层转换: 只有根级属性变为只读

```js
const state = shallowReadonly({
  foo: 1,
  nested: {
    bar: 2,
  },
});

// 更改状态自身的属性会失败
state.foo++;

// ...但可以更改下层嵌套对象
isReadonly(state.nested); // false

// 这是可以通过的
state.nested.bar++;
```

## toRaw()

根据一个 Vue 创建的代理返回其原始对象

toRaw() 可以返回由 reactive()、readonly()、shallowReactive() 或者 shallowReadonly() 创建的代理对应的原始对象。

```js
const foo = {};
const reactiveFoo = reactive(foo);

console.log(toRaw(reactiveFoo) === foo); // true
```

作用:
这是一个可以用于临时读取而不引起代理访问/跟踪开销, 或是写入而不出发更改的特殊方法.

## markRaw()

将一个对象标记为不可被转为代理. 返回该对象本身

```js
const foo = markRaw({});
console.log(isReactive(reactive(foo))); // false

// 也适用于嵌套在其他响应性对象
const bar = reactive({ foo });
console.log(isReactive(bar.foo)); // false
```

## effectScope()

创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。

```js
const scope = effectScope();

scope.run(() => {
  const doubled = computed(() => counter.value * 2);

  watch(doubled, () => console.log(doubled.value));

  watchEffect(() => console.log('Count: ', doubled.value));
});

// 处理掉当前作用域内的所有 effect
scope.stop();
```

我们不用在手动释放 watch, watchEffect 等监听器

其实如果实在单文件组件中, 这些是不需要的

## getCurrentScope()

## onScopeDispose()


