# Object 介绍

在 JS 中, 几乎所有的对象都是 Object 类型的实例

Object 构造函数为给定参数创建一个`包装类型` 有以下几种情况

- 如果给定值是 null 或者 undefined, 则返回空对象
- 如果传入一个基础类型值, 则会构造其包装类型的对象
- 如果传入的是引用对象, 则原样返回

## 增加属性

1. 直接通过字面量形式
2. 通过 `Object.defineProperty()` 来定义新属性
   > 该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（for...in 或 Object.keys 方法），可以改变这些属性的值，也可以删除这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 Object.defineProperty() 添加的属性值是不可修改的, 不可枚举的。

### 原型赋值时候的屏蔽现象

例如我没给一个对象赋值`myObject.bar = 'foo'`, 会有以下三种情况

1. 如果在原型链上层存在`bar`属性, 且是普通属性, 则会在 `myObject` 上创建一个 `bar` 属性, 并赋值
2. 如果在原型链上存在`writable: false` 的`bar`属性, 则赋值会失败, 在严格模式下还会抛出错误
3. 如果在原型链上存在一个 bar 的 `setter`, 那就一定会调用这个 setter, `bar` 不会被添加到`myObject`

> 第二种情况最让人意外, 只读属性会阻止链下层隐式创建同名属性

> 更奇怪的是, 这个限制只发生在 `=` 赋值, 使用`Object.defineProperty()` 并不会收到影响
> 关于这一点, 在`犀牛书`上有说明 **属性赋值查询原型链只为确定是否允许赋值**

查询属性时会用到原型链, 而设置属性时不影响原型链是一个重要的 JS 特性

属性赋值要么失败, 要么在对象上创建或设置值, 但有一个例外, 如果 `o` 继承一个属性`x`, 而`x`有`setter`, 则不会失败, 也不会创建(上面的第三点)

示例二

```js
var aObj = { a: 1 };
var bObj = Object.create(aObj);

bObj.a++;

aObj.a; // 1 (没想到吧)
bObj.a; // 2
```

首先 `bObj.a++` 等同于 `bObj.a = bObj.a + 1`, 先从原型链获取值, 然后再在`bObj`上创建`a`属性并赋值

**属性赋值失败情况**

1. 有一个只读自有属性 p: 不可能设置只读属性
2. 有一个只读继承属性 p: 不可能用同名自有属性隐藏只读继承属性
3. 没有自有属性 p, o 没有继承通过 setter 方法定义的属性 p, o 的 extensible: false, 则不能将 p 定义在 o 上

## 属性删除

要删除 Object 上的属性, 需要用到 `delete` 操作符, Object 上并没有提供可以用于删除属性的方法

使用 `delete` 需要考虑一下几点

1. delete 操作符只删除自有属性, 不删除继承属性
2. delete 不会删除 configurable 为 false 的属性, 严格模式下抛出错误, 非严格模式下返回 false
3. 任何使用 `var` 声明的属性不从全局作用域或函数作用域中删除, 会返回 false;
4. 任何用 let 或 const 声明的属性不能够从它被声明的作用域中删除, 会返回 false;

在 `Reflect` 出现之后, 可以通过 `Reflect.deleteProperty(obj, name)` 来删除属性

> Reflect.deleteProperty 的作用只是将 delete 操作函数化, **本质没变**

## 枚举

1. for...in
2. Object.keys
3. Object.entries

for...in 循环需要注意的是, 它会枚举原型链上可以被枚举的属性, 其他两个不会;

> 需要关注下枚举顺序

**ES6 正式定义了枚举对象自有属性的顺序**

1. 先列出名字为非负整数的字符串属性, 按照数值顺序从小到大. **这条规则意味着数组和类数组对象的属性会按照顺序被枚举**
2. 在列出数组索引的所有属性之后, 在列出所有剩下的字符串名字(包括看起来像负数或浮点数的名字)的属性. 这些属性按照他们添加到对象的先后顺序列出. 对于在对象字面量中定义的属性, 按照他们在字面量中出现的顺序列出
3. 名字为符号对象的属性按照他们添加到对象的先后顺序列出

for...in 的特殊性

> for...in 循环没有这么严格, 但实现通常会按照上面描述的顺序枚举自由属性, 在沿着原型链上溯, 以同样顺序枚举
